"""
Comprehensive Integration Tests for Exchanges Module

This test suite provides comprehensive coverage of the exchanges module integration
with all T-Bot dependencies to achieve 70% coverage target.

Tests cover:
1. Core module integration (config, DI, logging, types, base classes)
2. Utils module integration (decorators, validation, conversions)
3. Error handling integration (circuit breakers, retry, fallbacks)
4. Database integration (repository pattern, Redis caching)
5. Cross-module integration (bot_management, data, capital, web)
6. Production readiness validation
7. Performance and concurrency testing
"""

import asyncio
import time
from collections.abc import AsyncIterator, Callable
from decimal import Decimal
from typing import Any
from unittest.mock import AsyncMock, MagicMock, Mock, patch

import pytest

# Core module integration imports
from src.core.base import BaseComponent, BaseService
from src.core.base.health import HealthCheckResult
from src.core.base.interfaces import HealthStatus
from src.core.config import Config
from src.core.dependency_injection import DependencyInjector
from src.core.exceptions import (
    ExchangeConnectionError,
    ExchangeRateLimitError,
    OrderRejectionError,
    ServiceError,
    ValidationError,
)
from src.core.logging import get_logger
from src.core.types import (
    ExchangeInfo,
    MarketData,
    OrderBook,
    OrderRequest,
    OrderResponse,
    OrderSide,
    OrderStatus,
    OrderType,
    Position,
    StateType,
    Ticker,
    Trade,
)

# Utils module integration imports
from src.utils.decorators import cached, logged, retry, circuit_breaker
from src.utils.exchange_conversion_utils import SymbolConversionUtils

# Error handling integration imports
from src.error_handling.decorators import with_circuit_breaker, with_retry
from src.error_handling.error_handler import ErrorHandler

# Exchanges module imports
from src.exchanges.base import BaseExchange
from src.exchanges.connection_manager import ConnectionManager
from src.exchanges.di_registration import create_exchange_di_container
from src.exchanges.factory import ExchangeFactory
from src.exchanges.interfaces import IExchange, IExchangeFactory, IStateService
from src.exchanges.repository import ExchangeOrderRepository
from src.exchanges.service import ExchangeService
from src.exchanges.types import ExchangeCapability, ExchangeRateLimit, ExchangeTypes
from src.exchanges.validation import ExchangeValidator

logger = get_logger(__name__)


class ComprehensiveTestExchange(BaseExchange):
    """
    Comprehensive test exchange implementation that exercises all BaseExchange functionality
    to achieve maximum coverage.
    """

    def __init__(self, config: Config, exchange_name: str):
        super().__init__(config, exchange_name)
        self.connected = False
        self.order_count = 0
        self.trade_count = 0
        self.connection_attempts = 0
        self.last_error = None
        self.market_data_cache = {}
        
        # Initialize test state for coverage
        self._initialize_test_components()

    def _initialize_test_components(self):
        """Initialize components for comprehensive testing."""
        # Create real connection manager for testing
        from src.exchanges.connection_manager import ConnectionManager
        from src.exchanges.rate_limiter import RateLimiter
        
        self.rate_limiter = RateLimiter(self.config, self.exchange_name)
        self.connection_manager = ConnectionManager(self.config, self.exchange_name)
        
        # Initialize health status
        self._health_status = HealthStatus.HEALTHY
        self._last_health_check = None

    async def connect(self) -> bool:
        """Mock connection with comprehensive error scenarios."""
        self.connection_attempts += 1
        
        # Simulate connection delay
        await asyncio.sleep(0.01)
        
        # Test various connection scenarios
        if self.connection_attempts == 1:
            # First attempt succeeds
            self.connected = True
            return True
        elif self.connection_attempts == 2:
            # Second attempt fails (for error testing)
            raise ExchangeConnectionError("Connection failed for testing")
        else:
            # Subsequent attempts succeed
            self.connected = True
            return True

    async def disconnect(self) -> None:
        """Mock disconnection."""
        await asyncio.sleep(0.01)
        self.connected = False
        await self.connection_manager.cleanup()

    async def health_check(self) -> HealthCheckResult:
        """Comprehensive health check implementation."""
        try:
            # Test various health scenarios
            if not self.connected:
                return HealthCheckResult(
                    healthy=False,
                    status=HealthStatus.UNHEALTHY,
                    details={"error": "Not connected"},
                    latency_ms=0.0
                )
            
            start_time = time.time()
            
            # Simulate health check operations
            await asyncio.sleep(0.001)  # Simulate network latency
            
            latency = (time.time() - start_time) * 1000
            
            return HealthCheckResult(
                healthy=True,
                status=HealthStatus.HEALTHY,
                details={
                    "connection_attempts": self.connection_attempts,
                    "order_count": self.order_count,
                    "trade_count": self.trade_count
                },
                latency_ms=latency
            )
            
        except Exception as e:
            return HealthCheckResult(
                healthy=False,
                status=HealthStatus.CRITICAL,
                details={"error": str(e)},
                latency_ms=0.0
            )

    async def get_account_balance(self) -> dict[str, Decimal]:
        """Mock account balance with validation."""
        if not self.connected:
            raise ExchangeConnectionError("Exchange not connected")
        
        return {
            "BTC": Decimal("1.5"),
            "ETH": Decimal("10.25"),
            "USDT": Decimal("50000.00"),
            "BNB": Decimal("100.0")
        }

    async def get_positions(self) -> list[Position]:
        """Mock positions."""
        if not self.connected:
            raise ExchangeConnectionError("Exchange not connected")
            
        return [
            Position(
                symbol="BTCUSDT",
                size=Decimal("0.1"),
                side="long",
                entry_price=Decimal("50000.00"),
                mark_price=Decimal("51000.00"),
                unrealized_pnl=Decimal("100.00")
            )
        ]

    async def get_market_data(self, symbol: str, timeframe: str = "1m") -> MarketData:
        """Mock market data with caching."""
        if not symbol:
            raise ValidationError("Symbol cannot be empty")
            
        cache_key = f"{symbol}_{timeframe}"
        
        # Use cached data if available
        if cache_key in self.market_data_cache:
            return self.market_data_cache[cache_key]
        
        market_data = MarketData(
            symbol=symbol,
            timeframe=timeframe,
            open_price=Decimal("50000.00"),
            high_price=Decimal("51000.00"),
            low_price=Decimal("49000.00"),
            close_price=Decimal("50500.00"),
            volume=Decimal("1000.0"),
            timestamp=time.time()
        )
        
        # Cache the data
        self.market_data_cache[cache_key] = market_data
        return market_data

    async def get_ticker(self, symbol: str) -> Ticker:
        """Mock ticker with validation and error scenarios."""
        if not symbol:
            raise ValidationError("Symbol cannot be empty")
            
        if symbol == "INVALID":
            raise ValidationError("Invalid symbol")
            
        return Ticker(
            symbol=symbol,
            bid=Decimal("49999.00"),
            ask=Decimal("50001.00"),
            last_price=Decimal("50000.00"),
            volume_24h=Decimal("1000.0"),
            price_change_24h=Decimal("100.00"),
            timestamp=time.time()
        )

    async def get_order_book(self, symbol: str, depth: int = 10) -> OrderBook:
        """Mock order book with depth validation."""
        if not symbol:
            raise ValidationError("Symbol cannot be empty")
            
        if depth <= 0:
            raise ValidationError("Depth must be positive")
            
        # Generate bids and asks based on depth
        bids = [(Decimal("50000.00") - i, Decimal("1.0")) for i in range(depth)]
        asks = [(Decimal("50001.00") + i, Decimal("1.0")) for i in range(depth)]
        
        return OrderBook(
            symbol=symbol,
            bids=bids,
            asks=asks,
            timestamp=time.time()
        )

    async def place_order(self, order_request: OrderRequest) -> OrderResponse:
        """Comprehensive order placement with all validations."""
        if not self.connected:
            raise ExchangeConnectionError("Exchange not connected")
        
        # Validate order request
        if not order_request.symbol:
            raise ValidationError("Symbol is required")
        if order_request.quantity <= 0:
            raise ValidationError("Quantity must be positive")
        if order_request.side not in [OrderSide.BUY, OrderSide.SELL]:
            raise ValidationError("Invalid order side")
        if order_request.order_type not in [OrderType.MARKET, OrderType.LIMIT]:
            raise ValidationError("Invalid order type")
        if order_request.order_type == OrderType.LIMIT and not order_request.price:
            raise ValidationError("Price required for limit orders")
        
        # Simulate rate limiting
        await self.rate_limiter.acquire("orders_per_second", tokens=1, timeout=1.0)
        
        self.order_count += 1
        
        # Simulate order rejection for testing
        if order_request.symbol == "REJECT":
            raise OrderRejectionError("Order rejected for testing")
        
        return OrderResponse(
            id=f"order_{self.order_count}",
            symbol=order_request.symbol,
            quantity=order_request.quantity,
            side=order_request.side,
            order_type=order_request.order_type,
            status="FILLED" if order_request.order_type == OrderType.MARKET else "OPEN",
            price=order_request.price or Decimal("50000.00"),
            filled_quantity=order_request.quantity if order_request.order_type == OrderType.MARKET else Decimal("0"),
        )

    async def cancel_order(self, order_id: str) -> bool:
        """Mock order cancellation with validation."""
        if not order_id:
            raise ValidationError("Order ID cannot be empty")
            
        if order_id == "NOTFOUND":
            raise ValidationError("Order not found")
            
        return True

    async def get_order_status(self, order_id: str) -> OrderStatus:
        """Mock order status with validation."""
        if not order_id:
            raise ValidationError("Order ID cannot be empty")
            
        if order_id == "NOTFOUND":
            raise ValidationError("Order not found")
            
        return OrderStatus.FILLED

    async def get_trade_history(self, symbol: str, limit: int = 100) -> list[Trade]:
        """Mock trade history with validation."""
        if not symbol:
            raise ValidationError("Symbol cannot be empty")
            
        if limit <= 0 or limit > 1000:
            raise ValidationError("Limit must be between 1 and 1000")
        
        self.trade_count += 1
        
        return [
            Trade(
                id=f"trade_{self.trade_count}_{i}",
                symbol=symbol,
                price=Decimal("50000.00"),
                quantity=Decimal("0.001"),
                side=OrderSide.BUY if i % 2 == 0 else OrderSide.SELL,
                timestamp=time.time() - i * 60
            )
            for i in range(min(limit, 5))
        ]

    async def get_exchange_info(self) -> ExchangeInfo:
        """Mock exchange info."""
        return ExchangeInfo(
            name=self.exchange_name,
            supported_symbols=["BTCUSDT", "ETHUSDT", "BNBUSDT"],
            rate_limits={"requests_per_minute": 1200, "orders_per_second": 10},
            features=["spot_trading", "futures_trading"],
            api_version="v3",
        )

    async def subscribe_to_stream(self, symbol: str, callback: Callable) -> None:
        """Mock stream subscription."""
        if not symbol:
            raise ValidationError("Symbol cannot be empty")
            
        if not callback:
            raise ValidationError("Callback is required")
            
        # Simulate subscription
        await asyncio.sleep(0.01)
        logger.info(f"Subscribed to {symbol} stream")


@pytest.fixture
async def comprehensive_config() -> Config:
    """Create comprehensive test configuration."""
    config = Mock(spec=Config)
    
    # Core configuration
    config.environment = "test"
    config.log_level = "DEBUG"
    
    # Exchange configuration
    config.exchange = Mock()
    config.exchange.binance_api_key = "test_key"
    config.exchange.binance_api_secret = "test_secret"
    config.exchange.binance_testnet = True
    config.exchange.default_exchange = "test"
    config.exchange.max_connections = 10
    config.exchange.connection_timeout = 30.0
    config.exchange.get_exchange_credentials = Mock(
        return_value={"api_key": "test_key", "api_secret": "test_secret", "testnet": True}
    )
    
    # Database configuration
    config.database = Mock()
    config.database.url = "sqlite:///:memory:"
    config.database.postgresql_url = "postgresql://localhost:5432/test_db"
    config.database.pool_size = 5
    config.database.max_overflow = 10
    
    # Redis configuration
    config.redis = Mock()
    config.redis.host = "localhost"
    config.redis.port = 6379
    config.redis.db = 1
    config.redis.max_connections = 20
    
    # Rate limiting configuration
    config.rate_limits = Mock()
    config.rate_limits.requests_per_minute = 1200
    config.rate_limits.orders_per_second = 10
    config.rate_limits.websocket_connections = 5
    
    # Error handling configuration
    config.error_handling = Mock()
    config.error_handling.max_retries = 3
    config.error_handling.retry_delay = 1.0
    config.error_handling.circuit_breaker_threshold = 5
    
    return config


@pytest.fixture
async def mock_state_service() -> Mock:
    """Create mock state service for testing."""
    state_service = Mock(spec=IStateService)
    state_service.set_state = AsyncMock()
    state_service.get_state = AsyncMock(return_value={"test": "data"})
    state_service.delete_state = AsyncMock()
    state_service.update_state = AsyncMock()
    return state_service


@pytest.fixture
async def dependency_injector(comprehensive_config, mock_state_service) -> DependencyInjector:
    """Create configured dependency injector."""
    injector = DependencyInjector()
    
    # Register core services
    injector.register_service("config", comprehensive_config, singleton=True)
    injector.register_service("state_service", mock_state_service, singleton=True)
    injector.register_service("logger", get_logger(__name__), singleton=True)
    
    # Register exchange services
    exchange_factory = ExchangeFactory(comprehensive_config)
    injector.register_service("exchange_factory", exchange_factory, singleton=True)
    
    exchange_service = ExchangeService(exchange_factory=exchange_factory, config=comprehensive_config)
    injector.register_service("ExchangeService", exchange_service, singleton=True)
    
    return injector


class TestCoreModuleIntegration:
    """Test exchanges integration with core module."""

    async def test_base_component_inheritance(self, comprehensive_config):
        """Test that exchanges properly inherit from BaseComponent."""
        exchange = ComprehensiveTestExchange(comprehensive_config, "test")
        
        # Verify BaseComponent functionality
        assert isinstance(exchange, BaseComponent)
        assert exchange.component_name == "test"
        assert exchange.config == comprehensive_config
        
        # Test health check functionality
        await exchange.connect()
        health_result = await exchange.health_check()
        
        assert isinstance(health_result, HealthCheckResult)
        assert health_result.healthy is True
        assert health_result.status == HealthStatus.HEALTHY
        assert "connection_attempts" in health_result.details

    async def test_core_types_integration(self, comprehensive_config):
        """Test integration with core types."""
        exchange = ComprehensiveTestExchange(comprehensive_config, "test")
        await exchange.connect()
        
        # Test OrderRequest/OrderResponse types
        order_request = OrderRequest(
            symbol="BTCUSDT",
            quantity=Decimal("0.001"),
            side=OrderSide.BUY,
            order_type=OrderType.LIMIT,
            price=Decimal("50000.00"),
        )
        
        order_response = await exchange.place_order(order_request)
        
        assert isinstance(order_response, OrderResponse)
        assert order_response.symbol == "BTCUSDT"
        assert order_response.quantity == Decimal("0.001")
        assert order_response.side == OrderSide.BUY
        
        # Test MarketData types
        market_data = await exchange.get_market_data("BTCUSDT")
        
        assert isinstance(market_data, MarketData)
        assert market_data.symbol == "BTCUSDT"
        assert isinstance(market_data.open_price, Decimal)
        
        # Test Ticker types
        ticker = await exchange.get_ticker("BTCUSDT")
        
        assert isinstance(ticker, Ticker)
        assert ticker.symbol == "BTCUSDT"
        assert isinstance(ticker.last_price, Decimal)

    async def test_core_exceptions_integration(self, comprehensive_config):
        """Test integration with core exceptions."""
        exchange = ComprehensiveTestExchange(comprehensive_config, "test")
        
        # Test ValidationError
        with pytest.raises(ValidationError, match="Symbol cannot be empty"):
            await exchange.get_ticker("")
        
        # Test ExchangeConnectionError
        with pytest.raises(ExchangeConnectionError, match="Exchange not connected"):
            await exchange.get_account_balance()
        
        # Test OrderRejectionError
        await exchange.connect()
        order_request = OrderRequest(
            symbol="REJECT",
            quantity=Decimal("0.001"),
            side=OrderSide.BUY,
            order_type=OrderType.MARKET,
        )
        
        with pytest.raises(OrderRejectionError, match="Order rejected for testing"):
            await exchange.place_order(order_request)

    async def test_dependency_injection_integration(self, dependency_injector):
        """Test dependency injection integration."""
        # Test service resolution
        config = dependency_injector.resolve("config")
        assert config is not None
        
        exchange_factory = dependency_injector.resolve("exchange_factory")
        assert isinstance(exchange_factory, ExchangeFactory)
        
        exchange_service = dependency_injector.resolve("ExchangeService")
        assert isinstance(exchange_service, ExchangeService)
        
        # Test service dependencies
        assert exchange_service.config == config
        assert exchange_service.exchange_factory == exchange_factory

    async def test_logging_integration(self, comprehensive_config):
        """Test logging integration throughout exchanges."""
        exchange = ComprehensiveTestExchange(comprehensive_config, "test")
        
        # Test that logging works during operations
        with patch('src.exchanges.base.logger') as mock_logger:
            await exchange.connect()
            await exchange.subscribe_to_stream("BTCUSDT", lambda x: None)
            
            # Verify logging calls were made
            # Note: Since we're using a test exchange, we check info calls
            mock_logger.info.assert_called()


class TestUtilsModuleIntegration:
    """Test exchanges integration with utils module."""

    async def test_decorators_integration(self, comprehensive_config):
        """Test integration with utils decorators."""
        exchange = ComprehensiveTestExchange(comprehensive_config, "test")
        await exchange.connect()
        
        # Test that decorators are properly applied
        # The BaseExchange should use various decorators
        
        # Test caching behavior
        market_data_1 = await exchange.get_market_data("BTCUSDT")
        market_data_2 = await exchange.get_market_data("BTCUSDT")
        
        # Should return cached data (same object)
        assert market_data_1 is market_data_2

    async def test_validation_framework_integration(self, comprehensive_config):
        """Test integration with validation framework."""
        exchange = ComprehensiveTestExchange(comprehensive_config, "test")
        await exchange.connect()
        
        # Test validation in various operations
        with pytest.raises(ValidationError):
            await exchange.get_ticker("")
            
        with pytest.raises(ValidationError):
            await exchange.get_order_book("BTCUSDT", depth=0)
            
        with pytest.raises(ValidationError):
            order_request = OrderRequest(
                symbol="",
                quantity=Decimal("0.001"),
                side=OrderSide.BUY,
                order_type=OrderType.LIMIT,
                price=Decimal("50000.00"),
            )
            await exchange.place_order(order_request)

    async def test_exchange_conversion_utils_integration(self, comprehensive_config):
        """Test integration with exchange conversion utilities."""
        # Test SymbolConversionUtils functionality
        utils = SymbolConversionUtils()
        
        # Test symbol normalization
        normalized_symbol = utils.normalize_symbol("BTCUSDT")
        assert isinstance(normalized_symbol, str)
        
        # Test that the utils class is working
        assert utils is not None

    async def test_circuit_breaker_integration(self, comprehensive_config):
        """Test circuit breaker integration."""
        exchange = ComprehensiveTestExchange(comprehensive_config, "test")
        await exchange.connect()
        
        # Create a test method with circuit breaker
        @circuit_breaker(failure_threshold=2, recovery_timeout=1)
        async def test_operation():
            # Simulate failures
            if not hasattr(test_operation, 'call_count'):
                test_operation.call_count = 0
            test_operation.call_count += 1
            
            if test_operation.call_count <= 2:
                raise Exception("Simulated failure")
            return "success"
        
        # Test circuit breaker behavior
        with pytest.raises(Exception):
            await test_operation()
        
        with pytest.raises(Exception):
            await test_operation()
        
        # Circuit should be open now, next call should fail fast
        with pytest.raises(Exception):
            await test_operation()


class TestErrorHandlingIntegration:
    """Test exchanges integration with error handling module."""

    async def test_retry_mechanism_integration(self, comprehensive_config):
        """Test retry mechanism integration."""
        exchange = ComprehensiveTestExchange(comprehensive_config, "test")
        
        # Test connection retry
        connection_result = await exchange.connect()  # First attempt succeeds
        assert connection_result is True
        
        # Reset for second attempt
        exchange.connected = False
        
        # Second attempt should fail but be retried by error handler
        try:
            await exchange.connect()
        except ExchangeConnectionError:
            # Expected to fail on second attempt
            pass

    async def test_error_handler_integration(self, comprehensive_config):
        """Test error handler integration."""
        exchange = ComprehensiveTestExchange(comprehensive_config, "test")
        await exchange.connect()
        
        # Test error handling in operations
        with pytest.raises(ValidationError):
            await exchange.place_order(OrderRequest(
                symbol="INVALID_SYMBOL",
                quantity=Decimal("-1"),  # Invalid quantity
                side=OrderSide.BUY,
                order_type=OrderType.LIMIT,
                price=Decimal("50000.00"),
            ))

    async def test_fallback_strategies_integration(self, comprehensive_config):
        """Test fallback strategies integration."""
        factory = ExchangeFactory(comprehensive_config)
        factory.register_exchange("test", ComprehensiveTestExchange)
        
        # Test fallback when exchange fails
        exchange = await factory.get_exchange("test")
        await exchange.connect()
        
        # Verify fallback mechanisms work
        health_result = await exchange.health_check()
        assert health_result.healthy is True


class TestDatabaseIntegration:
    """Test exchanges integration with database module."""

    async def test_repository_pattern_integration(self, comprehensive_config):
        """Test repository pattern integration."""
        # Create connection manager for repository
        connection_manager = ConnectionManager(comprehensive_config, "test")
        
        # Create repository
        repository = ExchangeOrderRepository(connection_manager)
        
        # Mock the connection manager's request method
        connection_manager.request = AsyncMock(return_value={"orderId": "12345", "status": "FILLED"})
        
        # Test repository operations
        order_data = {
            "symbol": "BTCUSDT",
            "side": "BUY",
            "type": "MARKET",
            "quantity": "0.001"
        }
        
        result = await repository.place_order(order_data)
        assert result["orderId"] == "12345"
        
        # Test cancel order
        cancel_result = await repository.cancel_order("12345")
        assert cancel_result is not None

    async def test_redis_integration(self, comprehensive_config):
        """Test Redis integration for caching."""
        # Mock Redis client
        with patch('src.database.redis_client.RedisClient') as mock_redis:
            mock_redis_instance = Mock()
            mock_redis.return_value = mock_redis_instance
            mock_redis_instance.get = AsyncMock(return_value=None)
            mock_redis_instance.set = AsyncMock()
            
            exchange = ComprehensiveTestExchange(comprehensive_config, "test")
            await exchange.connect()
            
            # Test caching behavior
            market_data = await exchange.get_market_data("BTCUSDT")
            assert market_data is not None

    async def test_order_persistence_integration(self, comprehensive_config):
        """Test order persistence integration."""
        # Mock database operations
        with patch('src.database.service.DatabaseService') as mock_db:
            mock_db_instance = Mock()
            mock_db.return_value = mock_db_instance
            mock_db_instance.save_order = AsyncMock()
            mock_db_instance.get_order = AsyncMock(return_value={"id": "12345", "status": "FILLED"})
            
            exchange = ComprehensiveTestExchange(comprehensive_config, "test")
            await exchange.connect()
            
            # Test order persistence
            order_request = OrderRequest(
                symbol="BTCUSDT",
                quantity=Decimal("0.001"),
                side=OrderSide.BUY,
                order_type=OrderType.MARKET,
            )
            
            order_response = await exchange.place_order(order_request)
            assert order_response.id is not None


class TestCrossModuleIntegration:
    """Test exchanges integration with dependent modules."""

    async def test_bot_management_integration(self, comprehensive_config):
        """Test integration with bot_management module."""
        # Mock bot management service
        with patch('src.bot_management.service.BotManagementService') as mock_bot_service:
            mock_bot_instance = Mock()
            mock_bot_service.return_value = mock_bot_instance
            mock_bot_instance.get_active_bots = AsyncMock(return_value=[])
            
            factory = ExchangeFactory(comprehensive_config)
            factory.register_exchange("test", ComprehensiveTestExchange)
            
            exchange = await factory.get_exchange("test")
            
            # Verify exchange can be used by bot management
            assert exchange is not None
            assert exchange.connected is True

    async def test_data_pipeline_integration(self, comprehensive_config):
        """Test integration with data pipeline."""
        # Mock data service
        with patch('src.data.services.data_service.DataService') as mock_data_service:
            mock_data_instance = Mock()
            mock_data_service.return_value = mock_data_instance
            mock_data_instance.ingest_market_data = AsyncMock()
            
            exchange = ComprehensiveTestExchange(comprehensive_config, "test")
            await exchange.connect()
            
            # Test data pipeline integration
            market_data = await exchange.get_market_data("BTCUSDT")
            ticker = await exchange.get_ticker("BTCUSDT")
            
            # Verify data can be consumed by pipeline
            assert market_data is not None
            assert ticker is not None

    async def test_capital_management_integration(self, comprehensive_config):
        """Test integration with capital management."""
        # Mock capital management service
        with patch('src.capital_management.service.CapitalManagementService') as mock_capital:
            mock_capital_instance = Mock()
            mock_capital.return_value = mock_capital_instance
            mock_capital_instance.get_available_balance = AsyncMock(return_value=Decimal("10000"))
            
            exchange = ComprehensiveTestExchange(comprehensive_config, "test")
            await exchange.connect()
            
            # Test capital management integration
            balance = await exchange.get_account_balance()
            assert balance is not None
            assert "USDT" in balance

    async def test_web_interface_integration(self, comprehensive_config):
        """Test integration with web interface."""
        # Mock web interface health checks
        factory = ExchangeFactory(comprehensive_config)
        factory.register_exchange("test", ComprehensiveTestExchange)
        
        exchange = await factory.get_exchange("test")
        
        # Test health check endpoint integration
        health_result = await exchange.health_check()
        
        assert health_result.healthy is True
        assert isinstance(health_result.latency_ms, float)


class TestProductionReadinessValidation:
    """Test production readiness validation."""

    async def test_connection_resilience(self, comprehensive_config):
        """Test connection resilience under various conditions."""
        exchange = ComprehensiveTestExchange(comprehensive_config, "test")
        
        # Test multiple connection attempts
        for i in range(3):
            try:
                result = await exchange.connect()
                if result:
                    break
            except ExchangeConnectionError:
                # Expected for some attempts
                continue
        
        assert exchange.connected is True

    async def test_rate_limiting_compliance(self, comprehensive_config):
        """Test rate limiting compliance."""
        exchange = ComprehensiveTestExchange(comprehensive_config, "test")
        await exchange.connect()
        
        # Test rate limiting under load
        tasks = []
        for i in range(20):
            task = asyncio.create_task(exchange.get_ticker("BTCUSDT"))
            tasks.append(task)
        
        # Some requests might be rate limited
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # At least some should succeed
        successful_results = [r for r in results if not isinstance(r, Exception)]
        assert len(successful_results) > 0

    async def test_error_recovery_mechanisms(self, comprehensive_config):
        """Test error recovery mechanisms."""
        exchange = ComprehensiveTestExchange(comprehensive_config, "test")
        await exchange.connect()
        
        # Test recovery from various errors
        try:
            await exchange.get_ticker("INVALID")
        except ValidationError:
            # Expected error
            pass
        
        # Exchange should still be functional
        ticker = await exchange.get_ticker("BTCUSDT")
        assert ticker is not None

    async def test_data_consistency_validation(self, comprehensive_config):
        """Test data consistency validation."""
        exchange = ComprehensiveTestExchange(comprehensive_config, "test")
        await exchange.connect()
        
        # Test data consistency across multiple calls
        ticker1 = await exchange.get_ticker("BTCUSDT")
        ticker2 = await exchange.get_ticker("BTCUSDT")
        
        # Data should be consistent
        assert ticker1.symbol == ticker2.symbol
        assert isinstance(ticker1.last_price, Decimal)
        assert isinstance(ticker2.last_price, Decimal)

    async def test_memory_and_resource_management(self, comprehensive_config):
        """Test memory and resource management."""
        factory = ExchangeFactory(comprehensive_config)
        factory.register_exchange("test", ComprehensiveTestExchange)
        
        # Create and cleanup multiple exchanges
        exchanges = []
        for i in range(5):
            exchange = await factory.get_exchange(f"test_{i}")
            exchanges.append(exchange)
        
        # Verify all created
        assert len(exchanges) == 5
        
        # Cleanup
        await factory.disconnect_all()
        
        # Verify cleanup
        for exchange in exchanges:
            assert not exchange.connected


class TestPerformanceAndConcurrency:
    """Test performance and concurrency scenarios."""

    async def test_concurrent_operations_performance(self, comprehensive_config):
        """Test performance under concurrent operations."""
        exchange = ComprehensiveTestExchange(comprehensive_config, "test")
        await exchange.connect()
        
        start_time = time.time()
        
        # Run concurrent operations
        tasks = []
        for i in range(50):
            if i % 5 == 0:
                task = exchange.get_ticker("BTCUSDT")
            elif i % 5 == 1:
                task = exchange.get_market_data("BTCUSDT")
            elif i % 5 == 2:
                task = exchange.get_order_book("BTCUSDT")
            elif i % 5 == 3:
                task = exchange.get_account_balance()
            else:
                task = exchange.get_trade_history("BTCUSDT")
            
            tasks.append(asyncio.create_task(task))
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        end_time = time.time()
        duration = end_time - start_time
        
        # Performance assertions
        assert duration < 5.0  # Should complete within 5 seconds
        
        # Check results
        successful_results = [r for r in results if not isinstance(r, Exception)]
        assert len(successful_results) > 40  # At least 80% success rate

    async def test_memory_usage_under_load(self, comprehensive_config):
        """Test memory usage under load."""
        factory = ExchangeFactory(comprehensive_config)
        factory.register_exchange("test", ComprehensiveTestExchange)
        
        # Create multiple exchanges and perform operations
        exchanges = []
        for i in range(3):
            exchange = await factory.get_exchange(f"test_{i}")
            exchanges.append(exchange)
        
        # Perform many operations
        all_tasks = []
        for exchange in exchanges:
            for j in range(20):
                task = asyncio.create_task(exchange.get_ticker("BTCUSDT"))
                all_tasks.append(task)
        
        results = await asyncio.gather(*all_tasks, return_exceptions=True)
        
        # Cleanup
        await factory.disconnect_all()
        
        # Verify results
        assert len(results) == 60  # 3 exchanges * 20 operations

    async def test_connection_pool_efficiency(self, comprehensive_config):
        """Test connection pool efficiency."""
        # Test connection reuse
        connection_manager = ConnectionManager(comprehensive_config, "test")
        
        # Create multiple connections to same endpoint
        connections = []
        for i in range(5):
            conn = await connection_manager.get_rest_connection("test_endpoint")
            connections.append(conn)
        
        # Verify connection reuse (all should be same instance)
        for i in range(1, 5):
            assert connections[i] is connections[0]

    async def test_websocket_performance(self, comprehensive_config):
        """Test WebSocket performance."""
        connection_manager = ConnectionManager(comprehensive_config, "test")
        
        # Create WebSocket connections
        ws_connections = []
        for i in range(3):
            ws = await connection_manager.create_websocket_connection(
                f"wss://test{i}.com/ws", f"test_ws_{i}"
            )
            ws_connections.append(ws)
        
        # Test concurrent connections
        connect_tasks = [ws.connect() for ws in ws_connections]
        results = await asyncio.gather(*connect_tasks)
        
        assert all(results)  # All connections should succeed
        
        # Cleanup
        disconnect_tasks = [ws.disconnect() for ws in ws_connections]
        await asyncio.gather(*disconnect_tasks)


class TestComprehensiveCoverageValidation:
    """Final validation tests to ensure comprehensive coverage."""

    async def test_all_base_exchange_methods_covered(self, comprehensive_config):
        """Test that all BaseExchange methods are properly covered."""
        exchange = ComprehensiveTestExchange(comprehensive_config, "test")
        await exchange.connect()
        
        # Test all major methods
        await exchange.health_check()
        await exchange.get_account_balance()
        await exchange.get_positions()
        await exchange.get_market_data("BTCUSDT")
        await exchange.get_ticker("BTCUSDT")
        await exchange.get_order_book("BTCUSDT")
        
        order_request = OrderRequest(
            symbol="BTCUSDT",
            quantity=Decimal("0.001"),
            side=OrderSide.BUY,
            order_type=OrderType.MARKET,
        )
        order_response = await exchange.place_order(order_request)
        
        await exchange.get_order_status(order_response.id)
        await exchange.cancel_order(order_response.id)
        await exchange.get_trade_history("BTCUSDT")
        await exchange.get_exchange_info()
        await exchange.subscribe_to_stream("BTCUSDT", lambda x: None)
        
        await exchange.disconnect()

    async def test_exchange_service_comprehensive_coverage(self, comprehensive_config):
        """Test comprehensive ExchangeService coverage."""
        factory = ExchangeFactory(comprehensive_config)
        factory.register_exchange("test", ComprehensiveTestExchange)
        
        service = ExchangeService(exchange_factory=factory, config=comprehensive_config)
        await service.start()
        
        try:
            # Test all service methods
            order_request = OrderRequest(
                symbol="BTCUSDT",
                quantity=Decimal("0.001"),
                side=OrderSide.BUY,
                order_type=OrderType.MARKET,
            )
            
            await service.place_order("test", order_request)
            await service.get_account_balance("test")
            await service.get_market_data("test", "BTCUSDT")
            await service.health_check("test")
            
        finally:
            await service.stop()

    async def test_factory_comprehensive_coverage(self, comprehensive_config):
        """Test comprehensive ExchangeFactory coverage."""
        factory = ExchangeFactory(comprehensive_config)
        
        # Test factory methods
        factory.register_exchange("test", ComprehensiveTestExchange)
        
        supported = factory.get_supported_exchanges()
        assert "test" in supported
        
        available = factory.get_available_exchanges()
        assert "test" in available
        
        assert factory.is_exchange_supported("test")
        
        exchange = await factory.get_exchange("test")
        assert exchange is not None
        
        health = await factory.health_check_all()
        assert "test" in health
        
        await factory.disconnect_all()
        
        removed = await factory.remove_exchange("test")
        assert removed is True


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])