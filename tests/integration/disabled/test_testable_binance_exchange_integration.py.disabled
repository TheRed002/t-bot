"""
Integration tests for TestableBinanceExchange

These tests validate the new testable Binance exchange architecture and
ensure high test coverage with proper dependency injection.
"""

import pytest
from datetime import datetime, timezone
from decimal import Decimal
from unittest.mock import AsyncMock, Mock, patch
from typing import Any, Dict

from src.core.config import Config
from src.core.exceptions import ExchangeConnectionError, ExchangeError
from src.core.types import OrderRequest, OrderSide, OrderType
from src.exchanges.testable_binance_exchange import (
    TestableBinanceExchange,
    BinanceAdapter,
    BinanceConnectionManager,
)
from src.exchanges.core.testable_base_exchange import (
    MockConnectionManager,
    MockRateLimiter,
    MockHealthMonitor,
)


@pytest.fixture
def mock_config():
    """Create a mock configuration for testing."""
    config = Mock(spec=Config)
    config.exchange = Mock()
    config.exchange.binance_api_key = "test_api_key"
    config.exchange.binance_api_secret = "test_api_secret"
    config.exchange.binance_testnet = True
    return config


@pytest.fixture
def mock_binance_adapter():
    """Create a mock Binance adapter for testing."""
    adapter = AsyncMock(spec=BinanceAdapter)
    
    # Mock order placement
    adapter.place_order.return_value = {
        'orderId': 12345,
        'symbol': 'BTCUSDT',
        'side': 'BUY',
        'type': 'MARKET',
        'origQty': '0.1',
        'status': 'FILLED',
        'transactTime': int(datetime.now().timestamp() * 1000)
    }
    
    # Mock order cancellation
    adapter.cancel_order.return_value = {
        'orderId': 12345,
        'status': 'CANCELED'
    }
    
    # Mock balance retrieval
    adapter.get_balance.return_value = {
        'BTC': {
            'free': '1.5',
            'locked': '0.0',
            'total': '1.5'
        },
        'USDT': {
            'free': '10000.0',
            'locked': '0.0', 
            'total': '10000.0'
        }
    }
    
    # Mock ticker retrieval
    adapter.get_ticker.return_value = {
        'symbol': 'BTCUSDT',
        'bid': '50000.00',
        'ask': '50001.00',
        'last': '50000.50',
        'volume': '1000.0',
        'timestamp': datetime.now(timezone.utc).isoformat()
    }
    
    # Mock order book
    adapter.get_order_book.return_value = {
        'symbol': 'BTCUSDT',
        'bids': [['50000.00', '1.5'], ['49999.00', '2.0']],
        'asks': [['50001.00', '1.2'], ['50002.00', '1.8']],
        'timestamp': datetime.now(timezone.utc).isoformat()
    }
    
    # Mock recent trades
    adapter.get_recent_trades.return_value = [
        {
            'id': 12345,
            'price': '50000.50',
            'qty': '0.1',
            'time': int(datetime.now().timestamp() * 1000),
            'isBuyerMaker': True
        }
    ]
    
    # Mock exchange info
    adapter.get_exchange_info.return_value = {
        'symbols': [
            {'symbol': 'BTCUSDT', 'status': 'TRADING'},
            {'symbol': 'ETHUSDT', 'status': 'TRADING'}
        ]
    }
    
    return adapter


@pytest.fixture
def testable_binance_exchange(mock_config, mock_binance_adapter):
    """Create a testable Binance exchange instance."""
    connection_manager = MockConnectionManager()
    rate_limiter = MockRateLimiter(max_requests=1200)
    health_monitor = MockHealthMonitor()
    
    exchange = TestableBinanceExchange(
        config=mock_config,
        connection_manager=connection_manager,
        rate_limiter=rate_limiter,
        health_monitor=health_monitor,
        adapter=mock_binance_adapter,
    )
    
    return exchange


class TestTestableBinanceExchange:
    """Test suite for TestableBinanceExchange."""
    
    @pytest.mark.asyncio
    async def test_initialization(self, mock_config):
        """Test exchange initialization with proper dependency injection."""
        exchange = TestableBinanceExchange(config=mock_config)
        
        assert exchange.exchange_name == "binance"
        assert exchange._binance_config['api_key'] == "test_api_key"
        assert exchange._binance_config['api_secret'] == "test_api_secret"
        assert exchange._binance_config['testnet'] is True
        assert isinstance(exchange._connection_manager, BinanceConnectionManager)
    
    @pytest.mark.asyncio
    async def test_initialization_with_defaults(self):
        """Test exchange initialization with default dependencies."""
        exchange = TestableBinanceExchange()
        
        assert exchange.exchange_name == "binance"
        assert exchange._connection_manager is not None
        assert exchange._rate_limiter is not None
        assert exchange._health_monitor is not None
        assert exchange._adapter is not None
    
    @pytest.mark.asyncio
    async def test_connection_lifecycle(self, testable_binance_exchange):
        """Test connection and disconnection lifecycle."""
        exchange = testable_binance_exchange
        
        # Test connection
        success = await exchange.connect()
        assert success is True
        assert exchange.is_connected() is True
        
        # Test health check
        health = await exchange.health_check()
        assert health is True
        
        # Test disconnection
        await exchange.disconnect()
        assert exchange.is_connected() is False
    
    @pytest.mark.asyncio
    async def test_place_order_success(self, testable_binance_exchange):
        """Test successful order placement."""
        exchange = testable_binance_exchange
        await exchange.connect()
        
        result = await exchange.place_order(
            symbol="BTCUSDT",
            side="BUY",
            order_type="MARKET",
            quantity=Decimal("0.1")
        )
        
        assert result is not None
        assert result['symbol'] == 'BTCUSDT'
        assert result['side'] == 'BUY'
        assert result['type'] == 'MARKET'
        
        # Verify adapter was called
        exchange._adapter.place_order.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_place_order_not_connected(self, testable_binance_exchange):
        """Test order placement when not connected."""
        exchange = testable_binance_exchange
        
        with pytest.raises(RuntimeError, match="not connected"):
            await exchange.place_order(
                symbol="BTCUSDT",
                side="BUY", 
                order_type="MARKET",
                quantity=Decimal("0.1")
            )
    
    @pytest.mark.asyncio
    async def test_place_order_rate_limited(self, testable_binance_exchange):
        """Test order placement with rate limiting."""
        exchange = testable_binance_exchange
        await exchange.connect()
        
        # Exhaust rate limiter
        exchange._rate_limiter.current_requests = exchange._rate_limiter.max_requests
        
        with pytest.raises(RuntimeError, match="Rate limit exceeded"):
            await exchange.place_order(
                symbol="BTCUSDT",
                side="BUY",
                order_type="MARKET", 
                quantity=Decimal("0.1")
            )
    
    @pytest.mark.asyncio
    async def test_cancel_order_success(self, testable_binance_exchange):
        """Test successful order cancellation."""
        exchange = testable_binance_exchange
        await exchange.connect()
        
        result = await exchange.cancel_order("12345", "BTCUSDT")
        
        assert result is True
        exchange._adapter.cancel_order.assert_called_once_with("12345", symbol="BTCUSDT")
    
    @pytest.mark.asyncio
    async def test_get_balance_success(self, testable_binance_exchange):
        """Test successful balance retrieval."""
        exchange = testable_binance_exchange
        await exchange.connect()
        
        result = await exchange.get_balance()
        
        assert result is not None
        assert 'BTC' in result
        assert 'USDT' in result
        exchange._adapter.get_balance.assert_called_once_with(None)
    
    @pytest.mark.asyncio
    async def test_get_balance_specific_asset(self, testable_binance_exchange):
        """Test balance retrieval for specific asset."""
        exchange = testable_binance_exchange
        await exchange.connect()
        
        # Mock specific asset response
        exchange._adapter.get_balance.return_value = {
            'asset': 'BTC',
            'free': '1.5',
            'locked': '0.0',
            'total': '1.5'
        }
        
        result = await exchange.get_balance("BTC")
        
        assert result is not None
        exchange._adapter.get_balance.assert_called_once_with("BTC")
    
    @pytest.mark.asyncio
    async def test_get_ticker_success(self, testable_binance_exchange):
        """Test successful ticker retrieval."""
        exchange = testable_binance_exchange
        await exchange.connect()
        
        result = await exchange.get_ticker("BTCUSDT")
        
        assert result is not None
        assert result['symbol'] == 'BTCUSDT'
        assert 'bid' in result
        assert 'ask' in result
        exchange._adapter.get_ticker.assert_called_once_with("BTCUSDT")
    
    @pytest.mark.asyncio
    async def test_get_order_book_success(self, testable_binance_exchange):
        """Test successful order book retrieval."""
        exchange = testable_binance_exchange
        await exchange.connect()
        
        result = await exchange.get_order_book("BTCUSDT", depth=10)
        
        assert result is not None
        assert result.symbol == "BTCUSDT"
        assert len(result.bids) == 2
        assert len(result.asks) == 2
        assert result.exchange == "binance"
        
        # Verify adapter was called
        exchange._adapter.get_order_book.assert_called_once_with("BTCUSDT", 10)
    
    @pytest.mark.asyncio
    async def test_get_recent_trades_success(self, testable_binance_exchange):
        """Test successful recent trades retrieval."""
        exchange = testable_binance_exchange
        await exchange.connect()
        
        result = await exchange.get_recent_trades("BTCUSDT", limit=100)
        
        assert result is not None
        assert len(result) == 1
        assert result[0].symbol == "BTCUSDT"
        assert result[0].price == Decimal("50000.50")
        
        # Verify adapter was called
        exchange._adapter.get_recent_trades.assert_called_once_with("BTCUSDT", 100)
    
    @pytest.mark.asyncio
    async def test_get_exchange_info_success(self, testable_binance_exchange):
        """Test successful exchange info retrieval."""
        exchange = testable_binance_exchange
        await exchange.connect()
        
        result = await exchange.get_exchange_info()
        
        assert result is not None
        assert result.name == "binance"
        assert "BTCUSDT" in result.supported_symbols
        assert "ETHUSDT" in result.supported_symbols
        assert result.api_version == "v3"
        
        # Verify adapter was called
        exchange._adapter.get_exchange_info.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_error_handling(self, testable_binance_exchange):
        """Test error handling and health monitoring."""
        exchange = testable_binance_exchange
        await exchange.connect()
        
        # Configure adapter to raise an exception
        exchange._adapter.get_ticker.side_effect = ExchangeError("API Error")
        
        with pytest.raises(ExchangeError):
            await exchange.get_ticker("BTCUSDT")
        
        # Verify health monitor recorded the failure
        assert exchange._health_monitor.failure_count > 0
    
    @pytest.mark.asyncio
    async def test_websocket_subscription(self, testable_binance_exchange):
        """Test WebSocket stream subscription."""
        exchange = testable_binance_exchange
        await exchange.connect()
        
        # Mock WebSocket functionality
        mock_stream = AsyncMock()
        exchange._connection_manager.create_websocket_stream = AsyncMock(return_value=mock_stream)
        
        callback = Mock()
        
        # Test subscription
        await exchange.subscribe_to_stream("BTCUSDT", callback)
        
        # Verify stream was created
        exchange._connection_manager.create_websocket_stream.assert_called_once()
        
        # Verify subscription was stored
        assert "ticker_BTCUSDT" in exchange._ws_subscriptions


class TestBinanceAdapter:
    """Test suite for BinanceAdapter."""
    
    @pytest.fixture
    def binance_adapter(self, mock_config):
        """Create a Binance adapter for testing."""
        return BinanceAdapter(mock_config)
    
    def test_initialization(self, binance_adapter):
        """Test adapter initialization."""
        assert binance_adapter.api_key == "test_api_key"
        assert binance_adapter.api_secret == "test_api_secret"
        assert binance_adapter.testnet is True
        assert binance_adapter.client is None
    
    @pytest.mark.asyncio
    @patch('src.exchanges.testable_binance_exchange.AsyncClient')
    async def test_connect_success(self, mock_client_class, binance_adapter):
        """Test successful connection to Binance."""
        # Mock AsyncClient.create
        mock_client = AsyncMock()
        mock_client.get_server_time.return_value = {"serverTime": 1234567890}
        
        # Mock the create coroutine properly
        async def create_client(*args, **kwargs):
            return mock_client
        
        mock_client_class.create = create_client
        
        success = await binance_adapter.connect()
        
        assert success is True
        assert binance_adapter.client is not None
        mock_client.get_server_time.assert_called_once()
    
    @pytest.mark.asyncio
    @patch('src.exchanges.testable_binance_exchange.AsyncClient')
    async def test_connect_failure(self, mock_client_class, binance_adapter):
        """Test failed connection to Binance."""
        # Mock connection failure
        mock_client_class.create.side_effect = Exception("Connection failed")
        
        success = await binance_adapter.connect()
        
        assert success is False
        assert binance_adapter.client is None
    
    @pytest.mark.asyncio
    async def test_disconnect(self, binance_adapter):
        """Test disconnection from Binance."""
        # Set up connected state
        mock_client = AsyncMock()
        binance_adapter.client = mock_client
        
        await binance_adapter.disconnect()
        
        assert binance_adapter.client is None
        mock_client.close_connection.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_place_order_market_buy(self, binance_adapter):
        """Test market buy order placement."""
        # Mock connected client
        mock_client = AsyncMock()
        mock_client.order_market_buy.return_value = {"orderId": 12345}
        binance_adapter.client = mock_client
        
        result = await binance_adapter.place_order(
            symbol="BTCUSDT",
            side="BUY",
            order_type="MARKET",
            quantity=Decimal("0.1")
        )
        
        assert result["orderId"] == 12345
        mock_client.order_market_buy.assert_called_once_with(
            symbol="BTCUSDT",
            quantity="0.1"
        )
    
    @pytest.mark.asyncio
    async def test_place_order_limit(self, binance_adapter):
        """Test limit order placement."""
        # Mock connected client
        mock_client = AsyncMock()
        mock_client.order_limit.return_value = {"orderId": 12345}
        binance_adapter.client = mock_client
        
        result = await binance_adapter.place_order(
            symbol="BTCUSDT",
            side="BUY",
            order_type="LIMIT",
            quantity=Decimal("0.1"),
            price=Decimal("50000")
        )
        
        assert result["orderId"] == 12345
        mock_client.order_limit.assert_called_once_with(
            symbol="BTCUSDT",
            side="BUY",
            quantity="0.1",
            price="50000",
            timeInForce="GTC"
        )
    
    @pytest.mark.asyncio
    async def test_place_order_not_connected(self, binance_adapter):
        """Test order placement when not connected."""
        with pytest.raises(ExchangeConnectionError):
            await binance_adapter.place_order(
                symbol="BTCUSDT",
                side="BUY",
                order_type="MARKET",
                quantity=Decimal("0.1")
            )


class TestBinanceConnectionManager:
    """Test suite for BinanceConnectionManager."""
    
    @pytest.fixture
    def connection_manager(self, mock_config):
        """Create a Binance connection manager for testing."""
        return BinanceConnectionManager(mock_config)
    
    def test_initialization(self, connection_manager):
        """Test connection manager initialization."""
        assert connection_manager.config is not None
        assert connection_manager.adapter is not None
        assert connection_manager._connected is False
    
    @pytest.mark.asyncio
    @patch.object(BinanceAdapter, 'connect')
    async def test_connect_success(self, mock_connect, connection_manager):
        """Test successful connection."""
        mock_connect.return_value = True
        
        success = await connection_manager.connect()
        
        assert success is True
        assert connection_manager._connected is True
        mock_connect.assert_called_once()
    
    @pytest.mark.asyncio
    @patch.object(BinanceAdapter, 'connect')
    async def test_connect_failure(self, mock_connect, connection_manager):
        """Test failed connection."""
        mock_connect.return_value = False
        
        success = await connection_manager.connect()
        
        assert success is False
        assert connection_manager._connected is False
    
    @pytest.mark.asyncio
    @patch.object(BinanceAdapter, 'disconnect')
    async def test_disconnect(self, mock_disconnect, connection_manager):
        """Test disconnection."""
        connection_manager._connected = True
        
        await connection_manager.disconnect()
        
        assert connection_manager._connected is False
        mock_disconnect.assert_called_once()
    
    def test_is_connected(self, connection_manager):
        """Test connection status check."""
        # Not connected initially
        assert connection_manager.is_connected() is False
        
        # Mock connected state
        connection_manager._connected = True
        connection_manager.adapter.is_connected = Mock(return_value=True)
        
        assert connection_manager.is_connected() is True


@pytest.mark.asyncio
class TestIntegrationScenarios:
    """Integration test scenarios that test complete workflows."""
    
    async def test_complete_trading_workflow(self, testable_binance_exchange):
        """Test complete trading workflow from connection to order execution."""
        exchange = testable_binance_exchange
        
        # 1. Connect to exchange
        success = await exchange.connect()
        assert success is True
        
        # 2. Check balance
        balance = await exchange.get_balance()
        assert balance is not None
        
        # 3. Get market data
        ticker = await exchange.get_ticker("BTCUSDT")
        assert ticker is not None
        
        # 4. Place order
        order_result = await exchange.place_order(
            symbol="BTCUSDT",
            side="BUY",
            order_type="MARKET",
            quantity=Decimal("0.1")
        )
        assert order_result is not None
        
        # 5. Cancel order (if needed)
        cancel_result = await exchange.cancel_order("12345", "BTCUSDT")
        assert cancel_result is True
        
        # 6. Disconnect
        await exchange.disconnect()
        assert exchange.is_connected() is False
    
    async def test_error_recovery_workflow(self, testable_binance_exchange):
        """Test error recovery and resilience."""
        exchange = testable_binance_exchange
        await exchange.connect()
        
        # Configure adapter to fail first, then succeed
        call_count = 0
        
        def side_effect(*args, **kwargs):
            nonlocal call_count
            call_count += 1
            if call_count == 1:
                raise ExchangeError("Temporary failure")
            return {'symbol': 'BTCUSDT', 'bid': '50000.00', 'ask': '50001.00'}
        
        exchange._adapter.get_ticker.side_effect = side_effect
        
        # First call should fail
        with pytest.raises(ExchangeError):
            await exchange.get_ticker("BTCUSDT")
        
        # Reset side effect for second call
        exchange._adapter.get_ticker.side_effect = None
        exchange._adapter.get_ticker.return_value = {
            'symbol': 'BTCUSDT', 
            'bid': '50000.00', 
            'ask': '50001.00'
        }
        
        # Second call should succeed
        result = await exchange.get_ticker("BTCUSDT")
        assert result is not None
        
        # Verify health monitor tracked both failure and success
        assert exchange._health_monitor.failure_count >= 1
        assert exchange._health_monitor.success_count >= 1


if __name__ == "__main__":
    pytest.main([__file__, "-v"])