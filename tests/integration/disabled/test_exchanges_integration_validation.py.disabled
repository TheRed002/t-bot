"""
Integration tests for exchanges module dependency validation and boundary enforcement.

This test suite validates that the exchanges module correctly integrates with
other system modules and follows proper service layer patterns.
"""

from decimal import Decimal
from unittest.mock import AsyncMock, Mock, patch

import pytest

from src.core.dependency_injection import DependencyInjector
from src.core.exceptions import ServiceError, ValidationError
from src.core.types import (
    ExchangeInfo,
    MarketData,
    OrderBook,
    OrderRequest,
    OrderResponse,
    OrderSide,
    OrderType,
    Ticker,
)
from src.exchanges import register_exchange_services_with_di
from src.exchanges.di_registration import ExchangeDIContainer
from src.exchanges.factory import ExchangeFactory
from src.exchanges.interfaces import IExchange, IExchangeFactory
from src.exchanges.service import ExchangeService


class TestExchangesDependencyInjection:
    """Test dependency injection patterns in exchanges module."""

    @pytest.fixture
    async def config(self):
        """Create test configuration."""
        from unittest.mock import Mock

        # Create a mock config that behaves like the real Config but allows test parameters
        config = Mock()
        config.exchange = Mock()
        config.exchange.binance_api_key = "test_key"
        config.exchange.binance_api_secret = "test_secret"
        config.exchange.binance_testnet = True
        config.exchange.enabled_exchanges = ["binance"]
        config.exchange.get_exchange_credentials = Mock(
            return_value={"api_key": "test_key", "api_secret": "test_secret", "testnet": True}
        )
        config.database = Mock()
        config.database.url = "sqlite:///:memory:"
        config.database.postgresql_url = "postgresql://test:test@localhost:5432/test"
        config.redis = Mock()
        config.redis.host = "localhost"
        config.redis.port = 6379
        return config

    @pytest.fixture
    async def mock_exchange(self):
        """Create mock exchange following IExchange interface."""
        exchange = Mock(spec=IExchange)
        exchange.exchange_name = "binance"
        exchange.connect = AsyncMock(return_value=True)
        exchange.disconnect = AsyncMock()
        exchange.health_check = AsyncMock(return_value=True)
        exchange.is_connected = Mock(return_value=True)

        # Trading operations
        exchange.place_order = AsyncMock(
            return_value=OrderResponse(
                id="test_order_123",
                symbol="BTCUSDT",
                quantity=Decimal("0.001"),
                side=OrderSide.BUY,
                order_type=OrderType.LIMIT,
                status="FILLED",
                price=Decimal("50000"),
                filled_quantity=Decimal("0.001"),
            )
        )
        exchange.cancel_order = AsyncMock(return_value=True)
        exchange.get_order_status = AsyncMock(return_value="FILLED")

        # Market data operations
        exchange.get_market_data = AsyncMock(
            return_value=MarketData(
                symbol="BTCUSDT",
                timestamp=1234567890,
                open=Decimal("50000"),
                high=Decimal("51000"),
                low=Decimal("49000"),
                close=Decimal("50500"),
                volume=Decimal("100"),
            )
        )
        exchange.get_order_book = AsyncMock(
            return_value=OrderBook(
                symbol="BTCUSDT",
                timestamp=1234567890,
                bids=[(Decimal("50000"), Decimal("1.0"))],
                asks=[(Decimal("50001"), Decimal("1.0"))],
            )
        )
        exchange.get_ticker = AsyncMock(
            return_value=Ticker(
                symbol="BTCUSDT",
                bid=Decimal("50000"),
                ask=Decimal("50001"),
                last=Decimal("50000"),
                volume=Decimal("100"),
            )
        )
        exchange.get_trade_history = AsyncMock(return_value=[])

        # Account operations
        exchange.get_account_balance = AsyncMock(return_value={"BTC": Decimal("1.0")})
        exchange.get_positions = AsyncMock(return_value=[])
        exchange.get_exchange_info = AsyncMock(
            return_value=ExchangeInfo(name="binance", status="normal", timezone="UTC", symbols=[])
        )

        # WebSocket operations
        exchange.subscribe_to_stream = AsyncMock()

        return exchange

    async def test_exchange_service_dependency_injection(self, config):
        """Test that ExchangeService gets its dependencies injected correctly."""
        injector = DependencyInjector()

        # Mock exchange factory
        mock_factory = Mock(spec=IExchangeFactory)
        mock_factory.get_supported_exchanges = Mock(return_value=["binance"])
        mock_factory.get_available_exchanges = Mock(return_value=["binance"])

        # Register dependencies manually for testing
        injector.register_service("config", config, singleton=True)
        injector.register_service("IExchangeFactory", mock_factory, singleton=True)

        # Test service creation through DI
        service = ExchangeService(exchange_factory=mock_factory, config=config)

        # Verify dependencies are injected
        assert service.exchange_factory is mock_factory
        assert service.config is config
        assert service.name == "ExchangeService"

    async def test_exchange_factory_creation_through_di(self, config):
        """Test exchange factory creation through dependency injection."""
        injector = DependencyInjector()

        # Register with DI system
        register_exchange_services_with_di(config, injector)

        # Verify factory can be resolved
        factory = injector.resolve("ExchangeFactory")
        assert factory is not None
        assert isinstance(factory, ExchangeFactory)

        # Test singleton behavior
        factory2 = injector.resolve("ExchangeFactory")
        assert factory is factory2

    async def test_di_container_service_registration(self, config):
        """Test DI container properly registers all services."""
        injector = DependencyInjector()
        container = ExchangeDIContainer(config, injector)

        container.register_exchange_dependencies()

        # Verify core services are registered
        assert injector.has_service("config")
        assert injector.has_service("IExchangeFactory")
        assert injector.has_service("exchange_factory")
        assert injector.has_service("ExchangeService")

        # Verify services can be resolved
        config_resolved = injector.resolve("config")
        assert config_resolved is config

        factory = injector.resolve("IExchangeFactory")
        assert factory is not None

        service = injector.resolve("ExchangeService")
        assert service is not None
        assert isinstance(service, ExchangeService)

    async def test_service_dependencies_are_injected(self, config, mock_exchange):
        """Test that service layer gets proper dependency injection."""
        injector = DependencyInjector()

        # Create mock factory that returns our mock exchange
        mock_factory = Mock(spec=IExchangeFactory)
        mock_factory.get_exchange = AsyncMock(return_value=mock_exchange)

        # Register dependencies
        injector.register_service("config", config, singleton=True)
        injector.register_service("IExchangeFactory", mock_factory, singleton=True)

        # Create service with injected dependencies
        service = ExchangeService(exchange_factory=mock_factory, config=config)

        # Test that service uses injected factory
        exchange = await service.get_exchange("binance")
        assert exchange is mock_exchange
        mock_factory.get_exchange.assert_called_once_with(
            exchange_name="binance", create_if_missing=True
        )

    async def test_exchange_service_business_logic_integration(self, config, mock_exchange):
        """Test that ExchangeService properly implements business logic layer."""
        injector = DependencyInjector()

        # Mock factory
        mock_factory = Mock(spec=IExchangeFactory)
        mock_factory.get_exchange = AsyncMock(return_value=mock_exchange)

        # Create service
        service = ExchangeService(exchange_factory=mock_factory, config=config)

        # Test business logic validation
        order = OrderRequest(
            symbol="BTCUSDT",
            side=OrderSide.BUY,
            order_type=OrderType.LIMIT,
            quantity=Decimal("0.001"),
            price=Decimal("50000"),
        )

        # Test order placement through service layer
        response = await service.place_order("binance", order)

        # Verify service called exchange correctly
        mock_exchange.place_order.assert_called_once_with(order)
        assert response.symbol == "BTCUSDT"
        assert response.quantity == Decimal("0.001")

    async def test_error_handling_integration(self, config):
        """Test that exchanges module properly integrates with error handling."""
        injector = DependencyInjector()

        # Mock factory that raises exceptions
        mock_factory = Mock(spec=IExchangeFactory)
        mock_factory.get_exchange = AsyncMock(side_effect=Exception("Connection failed"))

        service = ExchangeService(exchange_factory=mock_factory, config=config)

        # Test error propagation
        with pytest.raises(ServiceError, match="Exchange retrieval failed"):
            await service.get_exchange("binance")

    async def test_validation_integration(self, config, mock_exchange):
        """Test that validation integrates properly with service layer."""
        injector = DependencyInjector()

        mock_factory = Mock(spec=IExchangeFactory)
        mock_factory.get_exchange = AsyncMock(return_value=mock_exchange)

        service = ExchangeService(exchange_factory=mock_factory, config=config)

        # Test validation errors
        invalid_order = OrderRequest(
            symbol="",  # Invalid empty symbol
            side=OrderSide.BUY,
            order_type=OrderType.LIMIT,
            quantity=Decimal("0.001"),
            price=Decimal("50000"),
        )

        with pytest.raises(ValidationError, match="Order symbol is required"):
            await service.place_order("binance", invalid_order)

    async def test_multi_exchange_integration(self, config):
        """Test handling multiple exchanges through service layer."""
        injector = DependencyInjector()

        # Mock exchanges
        binance_exchange = Mock(spec=IExchange)
        binance_exchange.exchange_name = "binance"
        binance_exchange.health_check = AsyncMock(return_value=True)

        okx_exchange = Mock(spec=IExchange)
        okx_exchange.exchange_name = "okx"
        okx_exchange.health_check = AsyncMock(return_value=True)

        # Mock factory that returns different exchanges
        mock_factory = Mock(spec=IExchangeFactory)

        def get_exchange_side_effect(exchange_name, **kwargs):
            if exchange_name == "binance":
                return binance_exchange
            elif exchange_name == "okx":
                return okx_exchange
            return None

        mock_factory.get_exchange = AsyncMock(side_effect=get_exchange_side_effect)
        mock_factory.get_available_exchanges = Mock(return_value=["binance", "okx"])

        service = ExchangeService(exchange_factory=mock_factory, config=config)

        # Test multiple exchange access
        binance = await service.get_exchange("binance")
        okx = await service.get_exchange("okx")

        assert binance.exchange_name == "binance"
        assert okx.exchange_name == "okx"

        # Test health check integration
        health = await service.get_service_health()
        assert health["service"] == "ExchangeService"
        assert len(health["exchanges"]) == 2


class TestExchangeModuleBoundaries:
    """Test module boundary enforcement and proper interface usage."""

    @pytest.fixture
    async def config(self):
        from unittest.mock import Mock

        config = Mock()
        config.exchange = Mock()
        config.exchange.binance_api_key = "test"
        config.exchange.binance_api_secret = "test"
        config.exchange.enabled_exchanges = ["binance"]
        config.exchange.get_exchange_credentials = Mock(
            return_value={"api_key": "test", "api_secret": "test", "testnet": True}
        )
        config.database = Mock()
        config.database.url = "sqlite:///:memory:"
        config.database.postgresql_url = "postgresql://test:test@localhost:5432/test"
        return config

    async def test_service_layer_isolation(self, config):
        """Test that service layer properly isolates business logic."""
        # Mock the underlying exchange to test service layer isolation
        with patch("src.exchanges.factory.ExchangeFactory") as mock_factory_class:
            mock_factory = Mock(spec=IExchangeFactory)
            mock_factory_class.return_value = mock_factory

            service = ExchangeService(exchange_factory=mock_factory, config=config)

            # Test that service doesn't expose internal implementation
            assert hasattr(service, "place_order")
            assert hasattr(service, "get_market_data")
            assert hasattr(service, "get_account_balance")

            # Test that service manages its own state
            assert hasattr(service, "_active_exchanges")
            assert isinstance(service._active_exchanges, dict)

    async def test_interface_compliance(self, config, mock_exchange):
        """Test that all exchanges comply with IExchange interface."""
        # Test that mock exchange implements all required methods
        required_methods = [
            "connect",
            "disconnect",
            "health_check",
            "is_connected",
            "place_order",
            "cancel_order",
            "get_order_status",
            "get_market_data",
            "get_order_book",
            "get_ticker",
            "get_trade_history",
            "get_account_balance",
            "get_positions",
            "get_exchange_info",
            "subscribe_to_stream",
        ]

        for method in required_methods:
            assert hasattr(mock_exchange, method), f"Exchange missing required method: {method}"

        # Test required properties
        assert hasattr(mock_exchange, "exchange_name")
        assert mock_exchange.exchange_name == "binance"

    async def test_no_circular_dependencies(self, config):
        """Test that exchanges module doesn't have circular dependencies."""
        # This test ensures the import structure is clean
        try:
            from src.exchanges import ExchangeFactory, ExchangeService
            from src.exchanges.factory import ExchangeFactory as FactoryClass
            from src.exchanges.interfaces import IExchange, IExchangeFactory
            from src.exchanges.service import ExchangeService as ServiceClass

            # Verify classes are properly imported
            assert ExchangeService is not None
            assert ExchangeFactory is not None
            assert IExchange is not None
            assert IExchangeFactory is not None

        except ImportError as e:
            pytest.fail(f"Circular dependency detected: {e}")

    async def test_proper_error_boundaries(self, config):
        """Test that errors are properly contained within module boundaries."""
        # Mock factory that raises internal errors
        mock_factory = Mock(spec=IExchangeFactory)
        mock_factory.get_exchange = AsyncMock(side_effect=RuntimeError("Internal error"))

        service = ExchangeService(exchange_factory=mock_factory, config=config)

        # Test that internal errors are converted to service errors
        with pytest.raises(ServiceError):
            await service.get_exchange("binance")

        # Verify the original error is not exposed
        try:
            await service.get_exchange("binance")
        except ServiceError as e:
            assert "Exchange retrieval failed" in str(e)
            assert "RuntimeError" not in str(e)  # Internal error type not exposed
        except Exception:
            pytest.fail("Should raise ServiceError, not internal exception")


class TestExchangeIntegrationUsagePatterns:
    """Test actual usage patterns found in the codebase."""

    @pytest.fixture
    async def config(self):
        from unittest.mock import Mock

        config = Mock()
        config.exchange = Mock()
        config.exchange.binance_api_key = "test"
        config.exchange.binance_api_secret = "test"
        config.exchange.enabled_exchanges = ["binance"]
        config.exchange.get_exchange_credentials = Mock(
            return_value={"api_key": "test", "api_secret": "test", "testnet": True}
        )
        config.database = Mock()
        config.database.url = "sqlite:///:memory:"
        config.database.postgresql_url = "postgresql://test:test@localhost:5432/test"
        return config

    async def test_capital_management_integration(self, config):
        """Test integration with capital management module."""
        # Test pattern found in capital_management/exchange_distributor.py
        from src.exchanges.interfaces import IExchange

        # Mock exchange for capital management usage
        mock_exchange = Mock(spec=IExchange)
        mock_exchange.get_account_balance = AsyncMock(return_value={"USDT": Decimal("1000")})
        mock_exchange.health_check = AsyncMock(return_value=True)

        # Test that capital management can properly use exchange interface
        balance = await mock_exchange.get_account_balance()
        assert "USDT" in balance
        assert balance["USDT"] == Decimal("1000")

        health = await mock_exchange.health_check()
        assert health is True

    async def test_bot_management_integration(self, config):
        """Test integration with bot management module."""
        # Test pattern found in bot_management/bot_instance.py
        mock_exchange = Mock(spec=IExchange)
        mock_exchange.place_order = AsyncMock(
            return_value=OrderResponse(
                id="bot_order_123",
                symbol="BTCUSDT",
                quantity=Decimal("0.01"),
                side=OrderSide.BUY,
                order_type=OrderType.MARKET,
                status="FILLED",
                price=Decimal("50000"),
                filled_quantity=Decimal("0.01"),
            )
        )

        # Test bot can place orders through exchange
        order = OrderRequest(
            symbol="BTCUSDT",
            side=OrderSide.BUY,
            order_type=OrderType.MARKET,
            quantity=Decimal("0.01"),
        )

        response = await mock_exchange.place_order(order)
        assert response.id == "bot_order_123"
        assert response.status == "FILLED"

    async def test_web_interface_integration(self, config):
        """Test integration with web interface health checks."""
        # Test pattern found in web_interface/api/health.py
        mock_factory = Mock(spec=IExchangeFactory)
        mock_factory.health_check_all = AsyncMock(
            return_value={"binance": {"healthy": True, "latency_ms": 50}}
        )

        health_status = await mock_factory.health_check_all()
        assert "binance" in health_status
        assert health_status["binance"]["healthy"] is True

    async def test_main_application_integration(self, config):
        """Test integration with main application startup."""
        # Test pattern found in main.py and __init__.py
        injector = DependencyInjector()

        # Test the actual registration function
        register_exchange_services_with_di(config, injector)

        # Verify services can be resolved for main app
        assert injector.has_service("config")
        assert injector.has_service("ExchangeFactory")

        # Test factory creation
        factory = injector.resolve("ExchangeFactory")
        assert factory is not None
