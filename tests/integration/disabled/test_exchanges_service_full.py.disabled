"""
Comprehensive Integration Tests for exchanges/service.py - Full Coverage

This test suite provides comprehensive integration testing for the ExchangeService class,
covering all business logic, service layer patterns, error handling, and integration points.

Target: Cover ALL of service.py (322 lines) to achieve 70% coverage target.
"""

from datetime import datetime, timezone
from decimal import Decimal
from unittest.mock import AsyncMock, Mock

import pytest

from src.core.config import Config
from src.core.exceptions import ServiceError, ValidationError
from src.core.types import (
    MarketData,
    OrderBook,
    OrderRequest,
    OrderResponse,
    OrderSide,
    OrderStatus,
    OrderType,
    Position,
    Ticker,
)
from src.exchanges.interfaces import IExchange, IExchangeFactory
from src.exchanges.service import ExchangeService


class MockExchange(Mock):
    """Mock exchange implementation."""

    def __init__(self, exchange_name: str = "mock_exchange"):
        super().__init__(spec=IExchange)
        self.exchange_name = exchange_name
        self._connected = False
        self._healthy = True

        # Configure async methods
        self.connect = AsyncMock(return_value=True)
        self.disconnect = AsyncMock()
        self.health_check = AsyncMock(return_value=self._healthy)
        self.place_order = AsyncMock()
        self.cancel_order = AsyncMock(return_value=True)
        self.get_order_status = AsyncMock(return_value=OrderStatus.FILLED)
        self.get_account_balance = AsyncMock(return_value={"BTC": Decimal("1.0")})
        self.get_order_book = AsyncMock()
        self.get_market_data = AsyncMock()
        self.get_ticker = AsyncMock()
        self.get_exchange_info = AsyncMock()
        self.get_positions = AsyncMock(return_value=[])
        self.get_open_orders = AsyncMock(return_value=[])
        self.subscribe_to_stream = AsyncMock()

    def set_healthy(self, healthy: bool):
        """Set health status for testing."""
        self._healthy = healthy
        self.health_check.return_value = healthy


class MockExchangeFactory(Mock):
    """Mock exchange factory implementation."""

    def __init__(self):
        super().__init__(spec=IExchangeFactory)
        self.exchanges = {}
        self.creation_calls = []

        # Configure async methods
        self.start = AsyncMock()
        self.stop = AsyncMock()
        self.get_exchange = AsyncMock(side_effect=self._get_exchange)
        self.create_exchange = AsyncMock(side_effect=self._create_exchange)
        self.remove_exchange = AsyncMock(return_value=True)
        self.connect_all = AsyncMock(return_value={})
        self.disconnect_all = AsyncMock()
        self.health_check_all = AsyncMock(return_value={})

    async def _get_exchange(self, exchange_name: str, create_if_missing: bool = False):
        """Mock get_exchange implementation."""
        if exchange_name in self.exchanges:
            return self.exchanges[exchange_name]
        elif create_if_missing:
            return await self._create_exchange(exchange_name)
        return None

    async def _create_exchange(self, exchange_name: str, **kwargs):
        """Mock create_exchange implementation."""
        self.creation_calls.append((exchange_name, kwargs))
        exchange = MockExchange(exchange_name)
        self.exchanges[exchange_name] = exchange
        return exchange

    def add_exchange(self, name: str, exchange: MockExchange):
        """Add exchange for testing."""
        self.exchanges[name] = exchange


@pytest.fixture
def mock_config():
    """Create mock configuration."""
    config = Mock(spec=Config)

    # Exchange service configuration
    service_config = Mock()
    service_config.default_timeout_seconds = 30
    service_config.max_retries = 3
    service_config.health_check_interval_seconds = 60
    config.exchange_service = service_config

    # Add to_dict method for BaseService
    config.to_dict = Mock(
        return_value={
            "exchange_service": {
                "default_timeout_seconds": 30,
                "max_retries": 3,
                "health_check_interval_seconds": 60,
            }
        }
    )

    return config


@pytest.fixture
def mock_exchange_factory():
    """Create mock exchange factory."""
    return MockExchangeFactory()


@pytest.fixture
def mock_error_handling_service():
    """Create mock error handling service."""
    return Mock()


@pytest.fixture
async def exchange_service(mock_config, mock_exchange_factory, mock_error_handling_service):
    """Create exchange service instance."""
    service = ExchangeService(
        exchange_factory=mock_exchange_factory,
        config=mock_config,
        error_handling_service=mock_error_handling_service,
        correlation_id="test-correlation-123",
    )
    yield service

    # Cleanup
    if service.is_running():
        await service.stop()


class TestExchangeServiceInitialization:
    """Test service initialization."""

    def test_service_creation(self, mock_config, mock_exchange_factory):
        """Test service creation with dependencies."""
        service = ExchangeService(
            exchange_factory=mock_exchange_factory, config=mock_config, correlation_id="test-123"
        )

        assert service.exchange_factory == mock_exchange_factory
        assert service.config == mock_config
        assert service.correlation_id == "test-123"
        assert service._default_timeout == 30
        assert service._max_retries == 3
        assert service._health_check_interval == 60

    def test_service_creation_without_config_to_dict(self, mock_exchange_factory):
        """Test service creation when config doesn't have to_dict method."""
        config = {"exchange_service": {"default_timeout_seconds": 45}}

        service = ExchangeService(exchange_factory=mock_exchange_factory, config=config)

        assert service.config == config
        assert service._default_timeout == 45

    def test_service_creation_minimal(self, mock_exchange_factory):
        """Test service creation with minimal config."""
        config = Mock()
        config.exchange_service = {}  # Empty config
        config.to_dict = Mock(return_value={})

        service = ExchangeService(exchange_factory=mock_exchange_factory, config=config)

        # Should use defaults
        assert service._default_timeout == 30
        assert service._max_retries == 3
        assert service._health_check_interval == 60


class TestExchangeServiceLifecycle:
    """Test service lifecycle management."""

    @pytest.mark.asyncio
    async def test_service_start(self, exchange_service, mock_exchange_factory):
        """Test service startup."""
        await exchange_service.start()

        assert exchange_service.is_running()
        mock_exchange_factory.start.assert_called_once()

    @pytest.mark.asyncio
    async def test_service_start_without_factory_start(self, mock_config):
        """Test service startup when factory doesn't have start method."""
        factory = Mock()  # No start method
        factory.spec = []

        service = ExchangeService(exchange_factory=factory, config=mock_config)

        # Should not raise exception
        await service.start()
        assert service.is_running()

    @pytest.mark.asyncio
    async def test_service_start_failure(self, mock_config, mock_exchange_factory):
        """Test service startup failure handling."""
        mock_exchange_factory.start.side_effect = Exception("Factory start failed")

        service = ExchangeService(exchange_factory=mock_exchange_factory, config=mock_config)

        with pytest.raises(ServiceError, match="Exchange service startup failed"):
            await service.start()

    @pytest.mark.asyncio
    async def test_service_stop(self, exchange_service, mock_exchange_factory):
        """Test service shutdown."""
        await exchange_service.start()

        # Add some active exchanges
        exchange = MockExchange("binance")
        exchange_service._active_exchanges["binance"] = exchange

        await exchange_service.stop()

        assert not exchange_service.is_running()
        exchange.disconnect.assert_called_once()
        mock_exchange_factory.stop.assert_called_once()

    @pytest.mark.asyncio
    async def test_service_stop_without_factory_stop(self, mock_config):
        """Test service shutdown when factory doesn't have stop method."""
        factory = Mock()  # No stop method
        factory.spec = []

        service = ExchangeService(exchange_factory=factory, config=mock_config)

        await service.start()

        # Should not raise exception
        await service.stop()
        assert not service.is_running()

    @pytest.mark.asyncio
    async def test_service_stop_with_error(self, exchange_service):
        """Test service shutdown with error handling."""
        await exchange_service.start()

        # Add exchange that fails to disconnect
        exchange = MockExchange("binance")
        exchange.disconnect.side_effect = Exception("Disconnect failed")
        exchange_service._active_exchanges["binance"] = exchange

        # Should handle error gracefully
        await exchange_service.stop()
        assert not exchange_service.is_running()


class TestExchangeServiceExchangeManagement:
    """Test exchange management operations."""

    @pytest.mark.asyncio
    async def test_get_exchange_new(self, exchange_service, mock_exchange_factory):
        """Test getting new exchange instance."""
        await exchange_service.start()

        exchange = await exchange_service.get_exchange("binance")

        assert exchange is not None
        assert exchange.exchange_name == "binance"
        assert "binance" in exchange_service._active_exchanges
        mock_exchange_factory.get_exchange.assert_called_once_with(
            exchange_name="binance", create_if_missing=True
        )

    @pytest.mark.asyncio
    async def test_get_exchange_existing_healthy(self, exchange_service):
        """Test getting existing healthy exchange."""
        await exchange_service.start()

        # Pre-populate with healthy exchange
        existing_exchange = MockExchange("binance")
        existing_exchange.set_healthy(True)
        exchange_service._active_exchanges["binance"] = existing_exchange

        exchange = await exchange_service.get_exchange("binance")

        assert exchange == existing_exchange
        existing_exchange.health_check.assert_called_once()

    @pytest.mark.asyncio
    async def test_get_exchange_existing_unhealthy(self, exchange_service, mock_exchange_factory):
        """Test getting existing unhealthy exchange."""
        await exchange_service.start()

        # Pre-populate with unhealthy exchange
        unhealthy_exchange = MockExchange("binance")
        unhealthy_exchange.set_healthy(False)
        exchange_service._active_exchanges["binance"] = unhealthy_exchange

        exchange = await exchange_service.get_exchange("binance")

        # Should create new exchange and remove unhealthy one
        assert exchange != unhealthy_exchange
        assert exchange.exchange_name == "binance"
        unhealthy_exchange.disconnect.assert_called_once()

    @pytest.mark.asyncio
    async def test_get_exchange_invalid_name(self, exchange_service):
        """Test getting exchange with invalid name."""
        await exchange_service.start()

        with pytest.raises(ValidationError, match="Exchange name is required"):
            await exchange_service.get_exchange("")

    @pytest.mark.asyncio
    async def test_get_exchange_factory_failure(self, exchange_service, mock_exchange_factory):
        """Test handling factory failure."""
        await exchange_service.start()

        mock_exchange_factory.get_exchange.return_value = None

        with pytest.raises(ServiceError, match="Failed to create exchange"):
            await exchange_service.get_exchange("binance")

    @pytest.mark.asyncio
    async def test_get_exchange_factory_exception(self, exchange_service, mock_exchange_factory):
        """Test handling factory exception."""
        await exchange_service.start()

        mock_exchange_factory.get_exchange.side_effect = Exception("Factory error")

        with pytest.raises(ServiceError, match="Exchange retrieval failed"):
            await exchange_service.get_exchange("binance")

    @pytest.mark.asyncio
    async def test_is_exchange_healthy(self, exchange_service):
        """Test exchange health checking."""
        exchange = MockExchange("binance")
        exchange.set_healthy(True)

        result = await exchange_service._is_exchange_healthy(exchange)
        assert result is True

        exchange.set_healthy(False)
        result = await exchange_service._is_exchange_healthy(exchange)
        assert result is False

    @pytest.mark.asyncio
    async def test_is_exchange_healthy_exception(self, exchange_service):
        """Test exchange health check with exception."""
        exchange = MockExchange("binance")
        exchange.health_check.side_effect = Exception("Health check failed")

        result = await exchange_service._is_exchange_healthy(exchange)
        assert result is False

    @pytest.mark.asyncio
    async def test_remove_exchange(self, exchange_service):
        """Test removing exchange from active pool."""
        exchange = MockExchange("binance")
        exchange_service._active_exchanges["binance"] = exchange

        await exchange_service._remove_exchange("binance")

        assert "binance" not in exchange_service._active_exchanges
        exchange.disconnect.assert_called_once()

    @pytest.mark.asyncio
    async def test_remove_exchange_nonexistent(self, exchange_service):
        """Test removing non-existent exchange."""
        # Should not raise exception
        await exchange_service._remove_exchange("nonexistent")

    @pytest.mark.asyncio
    async def test_remove_exchange_disconnect_error(self, exchange_service):
        """Test removing exchange with disconnect error."""
        exchange = MockExchange("binance")
        exchange.disconnect.side_effect = Exception("Disconnect failed")
        exchange_service._active_exchanges["binance"] = exchange

        # Should handle error gracefully
        await exchange_service._remove_exchange("binance")

        assert "binance" not in exchange_service._active_exchanges


class TestExchangeServiceTradingOperations:
    """Test trading operations through service layer."""

    @pytest.mark.asyncio
    async def test_place_order_success(self, exchange_service, mock_exchange_factory):
        """Test successful order placement."""
        await exchange_service.start()

        # Configure mock exchange
        exchange = MockExchange("binance")
        expected_response = OrderResponse(
            id="order_123",
            symbol="BTCUSDT",
            side=OrderSide.BUY,
            order_type=OrderType.MARKET,
            quantity=Decimal("1.0"),
            status=OrderStatus.FILLED,
            filled_quantity=Decimal("1.0"),
            created_at=datetime.now(timezone.utc),
        )
        exchange.place_order.return_value = expected_response
        mock_exchange_factory.exchanges["binance"] = exchange

        # Create order request
        order = OrderRequest(
            symbol="BTCUSDT",
            side=OrderSide.BUY,
            order_type=OrderType.MARKET,
            quantity=Decimal("1.0"),
        )

        # Place order
        response = await exchange_service.place_order("binance", order)

        assert response == expected_response
        exchange.place_order.assert_called_once_with(order)

    @pytest.mark.asyncio
    async def test_place_order_validation_failure(self, exchange_service):
        """Test order placement with validation failure."""
        await exchange_service.start()

        # Invalid order - no symbol
        order = OrderRequest(
            symbol="", side=OrderSide.BUY, order_type=OrderType.MARKET, quantity=Decimal("1.0")
        )

        with pytest.raises(ValidationError, match="Order symbol is required"):
            await exchange_service.place_order("binance", order)

    @pytest.mark.asyncio
    async def test_place_order_invalid_quantity(self, exchange_service):
        """Test order placement with invalid quantity."""
        await exchange_service.start()

        # Invalid order - zero quantity
        order = OrderRequest(
            symbol="BTCUSDT", side=OrderSide.BUY, order_type=OrderType.MARKET, quantity=Decimal("0")
        )

        with pytest.raises(ValidationError, match="Order quantity must be positive"):
            await exchange_service.place_order("binance", order)

    @pytest.mark.asyncio
    async def test_place_order_no_side(self, exchange_service):
        """Test order placement without side."""
        await exchange_service.start()

        order = OrderRequest(
            symbol="BTCUSDT", side=None, order_type=OrderType.MARKET, quantity=Decimal("1.0")
        )

        with pytest.raises(ValidationError, match="Order side is required"):
            await exchange_service.place_order("binance", order)

    @pytest.mark.asyncio
    async def test_place_order_exchange_error(self, exchange_service, mock_exchange_factory):
        """Test order placement with exchange error."""
        await exchange_service.start()

        # Configure mock exchange to fail
        exchange = MockExchange("binance")
        exchange.place_order.side_effect = Exception("Exchange error")
        mock_exchange_factory.exchanges["binance"] = exchange

        order = OrderRequest(
            symbol="BTCUSDT",
            side=OrderSide.BUY,
            order_type=OrderType.MARKET,
            quantity=Decimal("1.0"),
        )

        with pytest.raises(ServiceError, match="Failed to place order"):
            await exchange_service.place_order("binance", order)

    @pytest.mark.asyncio
    async def test_validate_order_request_valid(self, exchange_service):
        """Test valid order request validation."""
        order = OrderRequest(
            symbol="BTCUSDT",
            side=OrderSide.BUY,
            order_type=OrderType.MARKET,
            quantity=Decimal("1.0"),
        )

        # Should not raise exception
        await exchange_service._validate_order_request(order)

    @pytest.mark.asyncio
    async def test_process_order_response(self, exchange_service):
        """Test order response processing."""
        response = OrderResponse(
            id="order_123",
            symbol="BTCUSDT",
            side=OrderSide.BUY,
            order_type=OrderType.MARKET,
            quantity=Decimal("1.0"),
            status=OrderStatus.FILLED,
            filled_quantity=Decimal("1.0"),
            created_at=datetime.now(timezone.utc),
        )

        # Should not raise exception
        await exchange_service._process_order_response("binance", response)

    @pytest.mark.asyncio
    async def test_cancel_order_success(self, exchange_service, mock_exchange_factory):
        """Test successful order cancellation."""
        await exchange_service.start()

        exchange = MockExchange("binance")
        exchange.cancel_order.return_value = True
        mock_exchange_factory.exchanges["binance"] = exchange

        result = await exchange_service.cancel_order("binance", "order_123")

        assert result is True
        exchange.cancel_order.assert_called_once_with("order_123", None)

    @pytest.mark.asyncio
    async def test_cancel_order_invalid_id(self, exchange_service):
        """Test order cancellation with invalid order ID."""
        await exchange_service.start()

        with pytest.raises(ValidationError, match="Order ID is required"):
            await exchange_service.cancel_order("binance", "")

    @pytest.mark.asyncio
    async def test_cancel_order_exchange_error(self, exchange_service, mock_exchange_factory):
        """Test order cancellation with exchange error."""
        await exchange_service.start()

        exchange = MockExchange("binance")
        exchange.cancel_order.side_effect = Exception("Cancel failed")
        mock_exchange_factory.exchanges["binance"] = exchange

        with pytest.raises(ServiceError, match="Failed to cancel order"):
            await exchange_service.cancel_order("binance", "order_123")


class TestExchangeServiceMarketDataOperations:
    """Test market data operations through service layer."""

    @pytest.mark.asyncio
    async def test_get_market_data(self, exchange_service, mock_exchange_factory):
        """Test getting market data."""
        await exchange_service.start()

        expected_data = MarketData(
            symbol="BTCUSDT",
            price=Decimal("50000"),
            volume=Decimal("1000"),
            timestamp=datetime.now(timezone.utc),
        )

        exchange = MockExchange("binance")
        exchange.get_market_data.return_value = expected_data
        mock_exchange_factory.exchanges["binance"] = exchange

        data = await exchange_service.get_market_data("binance", "BTCUSDT")

        assert data == expected_data
        exchange.get_market_data.assert_called_once_with("BTCUSDT", "1m")

    @pytest.mark.asyncio
    async def test_get_market_data_with_timeframe(self, exchange_service, mock_exchange_factory):
        """Test getting market data with specific timeframe."""
        await exchange_service.start()

        exchange = MockExchange("binance")
        mock_exchange_factory.exchanges["binance"] = exchange

        await exchange_service.get_market_data("binance", "BTCUSDT", "1h")

        exchange.get_market_data.assert_called_once_with("BTCUSDT", "1h")

    @pytest.mark.asyncio
    async def test_get_market_data_validation_error(self, exchange_service):
        """Test market data request with validation error."""
        await exchange_service.start()

        with pytest.raises(ValidationError, match="Symbol is required"):
            await exchange_service.get_market_data("binance", "")

    @pytest.mark.asyncio
    async def test_get_order_book(self, exchange_service, mock_exchange_factory):
        """Test getting order book."""
        await exchange_service.start()

        expected_book = OrderBook(
            symbol="BTCUSDT",
            bids=[(Decimal("49900"), Decimal("1.0"))],
            asks=[(Decimal("50100"), Decimal("1.0"))],
            timestamp=datetime.now(timezone.utc),
        )

        exchange = MockExchange("binance")
        exchange.get_order_book.return_value = expected_book
        mock_exchange_factory.exchanges["binance"] = exchange

        book = await exchange_service.get_order_book("binance", "BTCUSDT")

        assert book == expected_book
        exchange.get_order_book.assert_called_once_with("BTCUSDT", 20)

    @pytest.mark.asyncio
    async def test_get_ticker(self, exchange_service, mock_exchange_factory):
        """Test getting ticker data."""
        await exchange_service.start()

        expected_ticker = Ticker(
            symbol="BTCUSDT",
            price=Decimal("50000"),
            bid=Decimal("49900"),
            ask=Decimal("50100"),
            volume=Decimal("1000"),
            timestamp=datetime.now(timezone.utc),
        )

        exchange = MockExchange("binance")
        exchange.get_ticker.return_value = expected_ticker
        mock_exchange_factory.exchanges["binance"] = exchange

        ticker = await exchange_service.get_ticker("binance", "BTCUSDT")

        assert ticker == expected_ticker
        exchange.get_ticker.assert_called_once_with("BTCUSDT")


class TestExchangeServiceAccountOperations:
    """Test account-related operations."""

    @pytest.mark.asyncio
    async def test_get_account_balance(self, exchange_service, mock_exchange_factory):
        """Test getting account balance."""
        await exchange_service.start()

        expected_balance = {"BTC": Decimal("1.5"), "USDT": Decimal("10000")}

        exchange = MockExchange("binance")
        exchange.get_account_balance.return_value = expected_balance
        mock_exchange_factory.exchanges["binance"] = exchange

        balance = await exchange_service.get_account_balance("binance")

        assert balance == expected_balance
        exchange.get_account_balance.assert_called_once()

    @pytest.mark.asyncio
    async def test_get_positions(self, exchange_service, mock_exchange_factory):
        """Test getting positions."""
        await exchange_service.start()

        expected_positions = [
            Position(
                symbol="BTCUSDT",
                size=Decimal("1.0"),
                side="long",
                entry_price=Decimal("48000"),
                mark_price=Decimal("50000"),
                unrealized_pnl=Decimal("2000"),
                timestamp=datetime.now(timezone.utc),
            )
        ]

        exchange = MockExchange("binance")
        exchange.get_positions.return_value = expected_positions
        mock_exchange_factory.exchanges["binance"] = exchange

        positions = await exchange_service.get_positions("binance")

        assert positions == expected_positions
        exchange.get_positions.assert_called_once()

    @pytest.mark.asyncio
    async def test_get_open_orders(self, exchange_service, mock_exchange_factory):
        """Test getting open orders."""
        await exchange_service.start()

        expected_orders = [
            OrderResponse(
                id="order_123",
                symbol="BTCUSDT",
                side=OrderSide.BUY,
                order_type=OrderType.LIMIT,
                quantity=Decimal("1.0"),
                price=Decimal("48000"),
                status=OrderStatus.PENDING,
                filled_quantity=Decimal("0"),
                created_at=datetime.now(timezone.utc),
            )
        ]

        exchange = MockExchange("binance")
        exchange.get_open_orders.return_value = expected_orders
        mock_exchange_factory.exchanges["binance"] = exchange

        orders = await exchange_service.get_open_orders("binance")

        assert orders == expected_orders
        exchange.get_open_orders.assert_called_once_with(None)


class TestExchangeServiceUtilityMethods:
    """Test utility and helper methods."""

    @pytest.mark.asyncio
    async def test_disconnect_all_exchanges(self, exchange_service):
        """Test disconnecting all active exchanges."""
        # Add multiple exchanges
        exchange1 = MockExchange("binance")
        exchange2 = MockExchange("coinbase")
        exchange_service._active_exchanges["binance"] = exchange1
        exchange_service._active_exchanges["coinbase"] = exchange2

        await exchange_service.disconnect_all_exchanges()

        exchange1.disconnect.assert_called_once()
        exchange2.disconnect.assert_called_once()
        assert len(exchange_service._active_exchanges) == 0

    @pytest.mark.asyncio
    async def test_disconnect_all_exchanges_with_error(self, exchange_service):
        """Test disconnecting all exchanges with error handling."""
        exchange1 = MockExchange("binance")
        exchange2 = MockExchange("coinbase")
        exchange1.disconnect.side_effect = Exception("Disconnect failed")

        exchange_service._active_exchanges["binance"] = exchange1
        exchange_service._active_exchanges["coinbase"] = exchange2

        # Should handle errors gracefully
        await exchange_service.disconnect_all_exchanges()

        exchange2.disconnect.assert_called_once()
        assert len(exchange_service._active_exchanges) == 0

    @pytest.mark.asyncio
    async def test_health_check_all_exchanges(self, exchange_service):
        """Test health checking all exchanges."""
        exchange1 = MockExchange("binance")
        exchange1.set_healthy(True)
        exchange2 = MockExchange("coinbase")
        exchange2.set_healthy(False)

        exchange_service._active_exchanges["binance"] = exchange1
        exchange_service._active_exchanges["coinbase"] = exchange2

        results = await exchange_service.health_check_all_exchanges()

        assert results["binance"] is True
        assert results["coinbase"] is False

    def test_get_active_exchanges(self, exchange_service):
        """Test getting active exchanges list."""
        exchange1 = MockExchange("binance")
        exchange2 = MockExchange("coinbase")

        exchange_service._active_exchanges["binance"] = exchange1
        exchange_service._active_exchanges["coinbase"] = exchange2

        active = exchange_service.get_active_exchanges()

        assert len(active) == 2
        assert "binance" in active
        assert "coinbase" in active


@pytest.mark.asyncio
async def test_comprehensive_service_integration(mock_config, mock_exchange_factory):
    """Test comprehensive service integration flow."""
    service = ExchangeService(
        exchange_factory=mock_exchange_factory,
        config=mock_config,
        correlation_id="integration-test",
    )

    try:
        # 1. Start service
        await service.start()
        assert service.is_running()

        # 2. Get exchange (creates new one)
        exchange = await service.get_exchange("binance")
        assert exchange.exchange_name == "binance"
        assert "binance" in service._active_exchanges

        # 3. Place order
        order = OrderRequest(
            symbol="BTCUSDT",
            side=OrderSide.BUY,
            order_type=OrderType.MARKET,
            quantity=Decimal("1.0"),
        )

        expected_response = OrderResponse(
            id="order_123",
            symbol="BTCUSDT",
            side=OrderSide.BUY,
            order_type=OrderType.MARKET,
            quantity=Decimal("1.0"),
            status=OrderStatus.FILLED,
            filled_quantity=Decimal("1.0"),
            created_at=datetime.now(timezone.utc),
        )
        exchange.place_order.return_value = expected_response

        response = await service.place_order("binance", order)
        assert response.id == "order_123"

        # 4. Cancel order
        exchange.cancel_order.return_value = True
        result = await service.cancel_order("binance", "order_123")
        assert result is True

        # 5. Get market data
        market_data = MarketData(
            symbol="BTCUSDT",
            price=Decimal("50000"),
            volume=Decimal("1000"),
            timestamp=datetime.now(timezone.utc),
        )
        exchange.get_market_data.return_value = market_data

        data = await service.get_market_data("binance", "BTCUSDT")
        assert data.symbol == "BTCUSDT"

        # 6. Health check all
        health_results = await service.health_check_all_exchanges()
        assert health_results["binance"] is True

        # 7. Get active exchanges
        active_exchanges = service.get_active_exchanges()
        assert "binance" in active_exchanges

    finally:
        # 8. Stop service
        await service.stop()
        assert not service.is_running()


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
