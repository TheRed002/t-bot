"""
Comprehensive Integration Tests for Exchange Implementations - Full Coverage

This test suite provides comprehensive integration testing for the exchange implementations:
- binance.py (524 lines, need 278+ more)
- coinbase.py (581 lines, need 307+ more)
- okx.py (similar structure)

Target: Cover ALL exchange implementation files to achieve 70% coverage target.
"""

import time
from datetime import datetime, timezone
from decimal import Decimal
from unittest.mock import AsyncMock, Mock, patch

import pytest

from src.core.base.interfaces import HealthStatus
from src.core.config import Config
from src.core.exceptions import (
    ExchangeError,
    ExchangeRateLimitError,
)
from src.core.types import (
    OrderRequest,
    OrderSide,
    OrderStatus,
    OrderType,
)


@pytest.fixture
def mock_config():
    """Create mock configuration for exchanges."""
    config = Mock(spec=Config)

    # Binance configuration
    config.binance = Mock()
    config.binance.api_key = "test_binance_key"
    config.binance.api_secret = "test_binance_secret"
    config.binance.sandbox = True
    config.binance.testnet = True

    # Coinbase configuration
    config.coinbase = Mock()
    config.coinbase.api_key = "test_coinbase_key"
    config.coinbase.api_secret = "test_coinbase_secret"
    config.coinbase.passphrase = "test_coinbase_passphrase"
    config.coinbase.sandbox = True

    # OKX configuration
    config.okx = Mock()
    config.okx.api_key = "test_okx_key"
    config.okx.api_secret = "test_okx_secret"
    config.okx.passphrase = "test_okx_passphrase"
    config.okx.sandbox = True

    # Exchange configuration
    config.exchange = Mock()
    config.exchange.get_connection_pool_config = Mock(
        return_value={
            "max_pool_size": 100,
            "pool_size": 30,
            "keepalive_timeout": 60,
            "request_timeout": 30,
            "connection_timeout": 10,
        }
    )
    config.exchange.rate_limits = {
        "binance": {"place_order": {"max_requests": 10}},
        "coinbase": {"place_order": {"max_requests": 5}},
        "okx": {"place_order": {"max_requests": 8}},
    }

    return config


@pytest.fixture
def mock_binance_client():
    """Create mock Binance client."""
    client = AsyncMock()

    # Mock API responses
    client.get_account = AsyncMock(
        return_value={
            "balances": [
                {"asset": "BTC", "free": "1.0", "locked": "0.0"},
                {"asset": "USDT", "free": "10000.0", "locked": "0.0"},
            ]
        }
    )

    client.get_order_book = AsyncMock(
        return_value={
            "bids": [["50000.00", "1.0"]],
            "asks": [["50100.00", "1.0"]],
            "lastUpdateId": 12345,
        }
    )

    client.create_order = AsyncMock(
        return_value={
            "orderId": 12345,
            "symbol": "BTCUSDT",
            "side": "BUY",
            "type": "MARKET",
            "quantity": "1.0",
            "status": "FILLED",
            "executedQty": "1.0",
            "cummulativeQuoteQty": "50000.0",
            "transactTime": int(time.time() * 1000),
        }
    )

    client.cancel_order = AsyncMock(return_value={"orderId": 12345, "status": "CANCELED"})

    client.get_order = AsyncMock(return_value={"orderId": 12345, "status": "FILLED"})

    client.get_ticker = AsyncMock(
        return_value={
            "symbol": "BTCUSDT",
            "price": "50000.00",
            "bidPrice": "49900.00",
            "askPrice": "50100.00",
            "volume": "1000.0",
        }
    )

    client.get_klines = AsyncMock(
        return_value=[
            [
                int(time.time() * 1000),  # Open time
                "50000.00",  # Open
                "50200.00",  # High
                "49800.00",  # Low
                "50100.00",  # Close
                "1000.0",  # Volume
                int(time.time() * 1000),  # Close time
                "50050000.0",  # Quote asset volume
                100,  # Number of trades
                "500.0",  # Taker buy base asset volume
                "25025000.0",  # Taker buy quote asset volume
                "0",  # Ignore
            ]
        ]
    )

    client.get_exchange_info = AsyncMock(
        return_value={
            "symbols": [
                {
                    "symbol": "BTCUSDT",
                    "status": "TRADING",
                    "baseAsset": "BTC",
                    "quoteAsset": "USDT",
                    "filters": [],
                }
            ]
        }
    )

    client.get_my_trades = AsyncMock(
        return_value=[
            {
                "id": 123,
                "symbol": "BTCUSDT",
                "price": "50000.00",
                "qty": "1.0",
                "isBuyer": True,
                "time": int(time.time() * 1000),
            }
        ]
    )

    return client


@pytest.fixture
def mock_coinbase_client():
    """Create mock Coinbase client."""
    client = AsyncMock()

    # Mock API responses
    client.get_accounts = AsyncMock(
        return_value=[
            {"currency": "BTC", "balance": "1.0", "available": "1.0"},
            {"currency": "USD", "balance": "10000.0", "available": "10000.0"},
        ]
    )

    client.get_product_order_book = AsyncMock(
        return_value={
            "bids": [["50000.00", "1.0", 1]],
            "asks": [["50100.00", "1.0", 1]],
            "sequence": 12345,
        }
    )

    client.place_order = AsyncMock(
        return_value={
            "id": "order-123",
            "product_id": "BTC-USD",
            "side": "buy",
            "type": "market",
            "size": "1.0",
            "status": "filled",
            "filled_size": "1.0",
            "executed_value": "50000.0",
            "created_at": datetime.now(timezone.utc).isoformat(),
        }
    )

    client.cancel_order = AsyncMock(return_value={"id": "order-123", "status": "cancelled"})

    client.get_order = AsyncMock(return_value={"id": "order-123", "status": "filled"})

    client.get_product_ticker = AsyncMock(
        return_value={
            "trade_id": 12345,
            "price": "50000.00",
            "bid": "49900.00",
            "ask": "50100.00",
            "volume": "1000.0",
            "time": datetime.now(timezone.utc).isoformat(),
        }
    )

    client.get_product_historic_rates = AsyncMock(
        return_value=[
            [
                int(time.time()),  # Time
                49800.00,  # Low
                50200.00,  # High
                50000.00,  # Open
                50100.00,  # Close
                1000.0,  # Volume
            ]
        ]
    )

    client.get_products = AsyncMock(
        return_value=[
            {
                "id": "BTC-USD",
                "display_name": "BTC/USD",
                "base_currency": "BTC",
                "quote_currency": "USD",
                "status": "online",
            }
        ]
    )

    return client


@pytest.fixture
def mock_okx_client():
    """Create mock OKX client."""
    client = AsyncMock()

    # Mock API responses following OKX format
    client.get_account_balance = AsyncMock(
        return_value={
            "data": [
                {
                    "details": [
                        {"ccy": "BTC", "availBal": "1.0", "frozenBal": "0.0"},
                        {"ccy": "USDT", "availBal": "10000.0", "frozenBal": "0.0"},
                    ]
                }
            ]
        }
    )

    client.get_orderbook = AsyncMock(
        return_value={
            "data": [
                {
                    "bids": [["50000.00", "1.0", "0", "1"]],
                    "asks": [["50100.00", "1.0", "0", "1"]],
                    "ts": str(int(time.time() * 1000)),
                }
            ]
        }
    )

    client.place_order = AsyncMock(
        return_value={
            "data": [
                {"ordId": "order-123", "clOrdId": "client-123", "sCode": "0", "sMsg": "success"}
            ]
        }
    )

    client.cancel_order = AsyncMock(return_value={"data": [{"ordId": "order-123", "sCode": "0"}]})

    client.get_order = AsyncMock(return_value={"data": [{"ordId": "order-123", "state": "filled"}]})

    client.get_ticker = AsyncMock(
        return_value={
            "data": [
                {
                    "instId": "BTC-USDT",
                    "last": "50000.0",
                    "bidPx": "49900.0",
                    "askPx": "50100.0",
                    "vol24h": "1000.0",
                }
            ]
        }
    )

    return client


class TestBinanceExchangeIntegration:
    """Test Binance exchange integration."""

    @pytest.mark.asyncio
    async def test_binance_creation(self, mock_config):
        """Test Binance exchange creation."""
        with (
            patch("src.exchanges.binance.AsyncClient"),
            patch("src.exchanges.base.get_global_rate_limiter"),
            patch("src.exchanges.base.RedisClient"),
            patch("src.exchanges.base.get_metrics_collector"),
            patch("aiohttp.TCPConnector"),
            patch("aiohttp.ClientSession"),
        ):
            from src.exchanges.binance import BinanceExchange

            exchange = BinanceExchange(mock_config)

            assert exchange.exchange_name == "binance"
            assert exchange.config == mock_config

    @pytest.mark.asyncio
    async def test_binance_connection(self, mock_config, mock_binance_client):
        """Test Binance connection process."""
        with (
            patch("src.exchanges.binance.AsyncClient.create") as mock_create,
            patch("src.exchanges.base.get_global_rate_limiter"),
            patch("src.exchanges.base.RedisClient"),
            patch("src.exchanges.base.get_metrics_collector"),
            patch("aiohttp.TCPConnector"),
            patch("aiohttp.ClientSession"),
        ):
            mock_create.return_value = mock_binance_client

            from src.exchanges.binance import BinanceExchange

            exchange = BinanceExchange(mock_config)

            result = await exchange.connect()

            assert result is True
            assert exchange.connected is True
            mock_create.assert_called_once()

    @pytest.mark.asyncio
    async def test_binance_connection_failure(self, mock_config):
        """Test Binance connection failure."""
        with (
            patch("src.exchanges.binance.AsyncClient.create") as mock_create,
            patch("src.exchanges.base.get_global_rate_limiter"),
            patch("src.exchanges.base.RedisClient"),
            patch("src.exchanges.base.get_metrics_collector"),
            patch("aiohttp.TCPConnector"),
            patch("aiohttp.ClientSession"),
        ):
            mock_create.side_effect = Exception("Connection failed")

            from src.exchanges.binance import BinanceExchange

            exchange = BinanceExchange(mock_config)

            result = await exchange.connect()

            assert result is False
            assert exchange.connected is False

    @pytest.mark.asyncio
    async def test_binance_place_order(self, mock_config, mock_binance_client):
        """Test placing order on Binance."""
        with (
            patch("src.exchanges.binance.AsyncClient.create") as mock_create,
            patch("src.exchanges.base.get_global_rate_limiter"),
            patch("src.exchanges.base.RedisClient"),
            patch("src.exchanges.base.get_metrics_collector"),
            patch("aiohttp.TCPConnector"),
            patch("aiohttp.ClientSession"),
        ):
            mock_create.return_value = mock_binance_client

            from src.exchanges.binance import BinanceExchange

            exchange = BinanceExchange(mock_config)
            await exchange.connect()

            order = OrderRequest(
                symbol="BTCUSDT",
                side=OrderSide.BUY,
                order_type=OrderType.MARKET,
                quantity=Decimal("1.0"),
            )

            response = await exchange.place_order(order)

            assert response.symbol == "BTCUSDT"
            assert response.side == OrderSide.BUY
            assert response.status == OrderStatus.FILLED
            mock_binance_client.create_order.assert_called_once()

    @pytest.mark.asyncio
    async def test_binance_get_account_balance(self, mock_config, mock_binance_client):
        """Test getting account balance from Binance."""
        with (
            patch("src.exchanges.binance.AsyncClient.create") as mock_create,
            patch("src.exchanges.base.get_global_rate_limiter"),
            patch("src.exchanges.base.RedisClient"),
            patch("src.exchanges.base.get_metrics_collector"),
            patch("aiohttp.TCPConnector"),
            patch("aiohttp.ClientSession"),
        ):
            mock_create.return_value = mock_binance_client

            from src.exchanges.binance import BinanceExchange

            exchange = BinanceExchange(mock_config)
            await exchange.connect()

            balance = await exchange.get_account_balance()

            assert "BTC" in balance
            assert "USDT" in balance
            assert balance["BTC"] == Decimal("1.0")
            assert balance["USDT"] == Decimal("10000.0")

    @pytest.mark.asyncio
    async def test_binance_get_order_book(self, mock_config, mock_binance_client):
        """Test getting order book from Binance."""
        with (
            patch("src.exchanges.binance.AsyncClient.create") as mock_create,
            patch("src.exchanges.base.get_global_rate_limiter"),
            patch("src.exchanges.base.RedisClient"),
            patch("src.exchanges.base.get_metrics_collector"),
            patch("aiohttp.TCPConnector"),
            patch("aiohttp.ClientSession"),
        ):
            mock_create.return_value = mock_binance_client

            from src.exchanges.binance import BinanceExchange

            exchange = BinanceExchange(mock_config)
            await exchange.connect()

            order_book = await exchange.get_order_book("BTCUSDT")

            assert order_book.symbol == "BTCUSDT"
            assert len(order_book.bids) > 0
            assert len(order_book.asks) > 0

    @pytest.mark.asyncio
    async def test_binance_cancel_order(self, mock_config, mock_binance_client):
        """Test cancelling order on Binance."""
        with (
            patch("src.exchanges.binance.AsyncClient.create") as mock_create,
            patch("src.exchanges.base.get_global_rate_limiter"),
            patch("src.exchanges.base.RedisClient"),
            patch("src.exchanges.base.get_metrics_collector"),
            patch("aiohttp.TCPConnector"),
            patch("aiohttp.ClientSession"),
        ):
            mock_create.return_value = mock_binance_client

            from src.exchanges.binance import BinanceExchange

            exchange = BinanceExchange(mock_config)
            await exchange.connect()

            result = await exchange.cancel_order("12345", "BTCUSDT")

            assert result is True
            mock_binance_client.cancel_order.assert_called_once()

    @pytest.mark.asyncio
    async def test_binance_get_ticker(self, mock_config, mock_binance_client):
        """Test getting ticker from Binance."""
        with (
            patch("src.exchanges.binance.AsyncClient.create") as mock_create,
            patch("src.exchanges.base.get_global_rate_limiter"),
            patch("src.exchanges.base.RedisClient"),
            patch("src.exchanges.base.get_metrics_collector"),
            patch("aiohttp.TCPConnector"),
            patch("aiohttp.ClientSession"),
        ):
            mock_create.return_value = mock_binance_client

            from src.exchanges.binance import BinanceExchange

            exchange = BinanceExchange(mock_config)
            await exchange.connect()

            ticker = await exchange.get_ticker("BTCUSDT")

            assert ticker.symbol == "BTCUSDT"
            assert ticker.price == Decimal("50000.00")

    @pytest.mark.asyncio
    async def test_binance_api_exception_handling(self, mock_config, mock_binance_client):
        """Test Binance API exception handling."""
        with (
            patch("src.exchanges.binance.AsyncClient.create") as mock_create,
            patch("src.exchanges.base.get_global_rate_limiter"),
            patch("src.exchanges.base.RedisClient"),
            patch("src.exchanges.base.get_metrics_collector"),
            patch("aiohttp.TCPConnector"),
            patch("aiohttp.ClientSession"),
            patch("src.exchanges.binance.BinanceAPIException") as mock_api_exception,
        ):
            mock_create.return_value = mock_binance_client
            mock_binance_client.get_account.side_effect = mock_api_exception("API Error")

            from src.exchanges.binance import BinanceExchange

            exchange = BinanceExchange(mock_config)
            await exchange.connect()

            with pytest.raises(ExchangeError):
                await exchange.get_account_balance()


class TestCoinbaseExchangeIntegration:
    """Test Coinbase exchange integration."""

    @pytest.mark.asyncio
    async def test_coinbase_creation(self, mock_config):
        """Test Coinbase exchange creation."""
        with (
            patch("src.exchanges.coinbase.cbpro.AuthenticatedClient"),
            patch("src.exchanges.base.get_global_rate_limiter"),
            patch("src.exchanges.base.RedisClient"),
            patch("src.exchanges.base.get_metrics_collector"),
            patch("aiohttp.TCPConnector"),
            patch("aiohttp.ClientSession"),
        ):
            from src.exchanges.coinbase import CoinbaseExchange

            exchange = CoinbaseExchange(mock_config)

            assert exchange.exchange_name == "coinbase"
            assert exchange.config == mock_config

    @pytest.mark.asyncio
    async def test_coinbase_connection(self, mock_config, mock_coinbase_client):
        """Test Coinbase connection process."""
        with (
            patch("src.exchanges.coinbase.cbpro.AuthenticatedClient") as mock_client_class,
            patch("src.exchanges.base.get_global_rate_limiter"),
            patch("src.exchanges.base.RedisClient"),
            patch("src.exchanges.base.get_metrics_collector"),
            patch("aiohttp.TCPConnector"),
            patch("aiohttp.ClientSession"),
        ):
            mock_client_class.return_value = mock_coinbase_client

            from src.exchanges.coinbase import CoinbaseExchange

            exchange = CoinbaseExchange(mock_config)

            result = await exchange.connect()

            assert result is True
            assert exchange.connected is True

    @pytest.mark.asyncio
    async def test_coinbase_place_order(self, mock_config, mock_coinbase_client):
        """Test placing order on Coinbase."""
        with (
            patch("src.exchanges.coinbase.cbpro.AuthenticatedClient") as mock_client_class,
            patch("src.exchanges.base.get_global_rate_limiter"),
            patch("src.exchanges.base.RedisClient"),
            patch("src.exchanges.base.get_metrics_collector"),
            patch("aiohttp.TCPConnector"),
            patch("aiohttp.ClientSession"),
        ):
            mock_client_class.return_value = mock_coinbase_client

            from src.exchanges.coinbase import CoinbaseExchange

            exchange = CoinbaseExchange(mock_config)
            await exchange.connect()

            order = OrderRequest(
                symbol="BTC-USD",
                side=OrderSide.BUY,
                order_type=OrderType.MARKET,
                quantity=Decimal("1.0"),
            )

            response = await exchange.place_order(order)

            assert response.symbol == "BTC-USD"
            assert response.side == OrderSide.BUY
            assert response.status == OrderStatus.FILLED

    @pytest.mark.asyncio
    async def test_coinbase_get_account_balance(self, mock_config, mock_coinbase_client):
        """Test getting account balance from Coinbase."""
        with (
            patch("src.exchanges.coinbase.cbpro.AuthenticatedClient") as mock_client_class,
            patch("src.exchanges.base.get_global_rate_limiter"),
            patch("src.exchanges.base.RedisClient"),
            patch("src.exchanges.base.get_metrics_collector"),
            patch("aiohttp.TCPConnector"),
            patch("aiohttp.ClientSession"),
        ):
            mock_client_class.return_value = mock_coinbase_client

            from src.exchanges.coinbase import CoinbaseExchange

            exchange = CoinbaseExchange(mock_config)
            await exchange.connect()

            balance = await exchange.get_account_balance()

            assert "BTC" in balance
            assert "USD" in balance
            assert balance["BTC"] == Decimal("1.0")
            assert balance["USD"] == Decimal("10000.0")


class TestOKXExchangeIntegration:
    """Test OKX exchange integration."""

    @pytest.mark.asyncio
    async def test_okx_creation(self, mock_config):
        """Test OKX exchange creation."""
        with (
            patch("src.exchanges.okx.okx_client.OKXRestClient"),
            patch("src.exchanges.base.get_global_rate_limiter"),
            patch("src.exchanges.base.RedisClient"),
            patch("src.exchanges.base.get_metrics_collector"),
            patch("aiohttp.TCPConnector"),
            patch("aiohttp.ClientSession"),
        ):
            from src.exchanges.okx import OKXExchange

            exchange = OKXExchange(mock_config)

            assert exchange.exchange_name == "okx"
            assert exchange.config == mock_config

    @pytest.mark.asyncio
    async def test_okx_connection(self, mock_config, mock_okx_client):
        """Test OKX connection process."""
        with (
            patch("src.exchanges.okx.okx_client.OKXRestClient") as mock_client_class,
            patch("src.exchanges.base.get_global_rate_limiter"),
            patch("src.exchanges.base.RedisClient"),
            patch("src.exchanges.base.get_metrics_collector"),
            patch("aiohttp.TCPConnector"),
            patch("aiohttp.ClientSession"),
        ):
            mock_client_class.return_value = mock_okx_client

            from src.exchanges.okx import OKXExchange

            exchange = OKXExchange(mock_config)

            result = await exchange.connect()

            assert result is True
            assert exchange.connected is True

    @pytest.mark.asyncio
    async def test_okx_get_account_balance(self, mock_config, mock_okx_client):
        """Test getting account balance from OKX."""
        with (
            patch("src.exchanges.okx.okx_client.OKXRestClient") as mock_client_class,
            patch("src.exchanges.base.get_global_rate_limiter"),
            patch("src.exchanges.base.RedisClient"),
            patch("src.exchanges.base.get_metrics_collector"),
            patch("aiohttp.TCPConnector"),
            patch("aiohttp.ClientSession"),
        ):
            mock_client_class.return_value = mock_okx_client

            from src.exchanges.okx import OKXExchange

            exchange = OKXExchange(mock_config)
            await exchange.connect()

            balance = await exchange.get_account_balance()

            assert "BTC" in balance
            assert "USDT" in balance
            assert balance["BTC"] == Decimal("1.0")
            assert balance["USDT"] == Decimal("10000.0")


class TestExchangeErrorHandling:
    """Test error handling across all exchange implementations."""

    @pytest.mark.asyncio
    async def test_binance_rate_limit_error(self, mock_config, mock_binance_client):
        """Test Binance rate limit error handling."""
        with (
            patch("src.exchanges.binance.AsyncClient.create") as mock_create,
            patch("src.exchanges.base.get_global_rate_limiter"),
            patch("src.exchanges.base.RedisClient"),
            patch("src.exchanges.base.get_metrics_collector"),
            patch("aiohttp.TCPConnector"),
            patch("aiohttp.ClientSession"),
            patch("src.exchanges.binance.BinanceAPIException") as mock_exception,
        ):
            mock_create.return_value = mock_binance_client

            # Simulate rate limit error
            rate_limit_error = mock_exception(None, -1003)  # Rate limit error code
            mock_binance_client.create_order.side_effect = rate_limit_error

            from src.exchanges.binance import BinanceExchange

            exchange = BinanceExchange(mock_config)
            await exchange.connect()

            order = OrderRequest(
                symbol="BTCUSDT",
                side=OrderSide.BUY,
                order_type=OrderType.MARKET,
                quantity=Decimal("1.0"),
            )

            with pytest.raises(ExchangeRateLimitError):
                await exchange.place_order(order)

    @pytest.mark.asyncio
    async def test_exchange_connection_error_recovery(self, mock_config):
        """Test exchange connection error recovery."""
        with (
            patch("src.exchanges.binance.AsyncClient.create") as mock_create,
            patch("src.exchanges.base.get_global_rate_limiter"),
            patch("src.exchanges.base.RedisClient"),
            patch("src.exchanges.base.get_metrics_collector"),
            patch("aiohttp.TCPConnector"),
            patch("aiohttp.ClientSession"),
        ):
            # First call fails, second succeeds
            mock_client = AsyncMock()
            mock_create.side_effect = [Exception("Connection failed"), mock_client]

            from src.exchanges.binance import BinanceExchange

            exchange = BinanceExchange(mock_config)

            # First connection attempt fails
            result1 = await exchange.connect()
            assert result1 is False

            # Second attempt succeeds
            result2 = await exchange.connect()
            assert result2 is True


class TestExchangeWebSocketIntegration:
    """Test WebSocket functionality across exchanges."""

    @pytest.mark.asyncio
    async def test_binance_websocket_subscription(self, mock_config, mock_binance_client):
        """Test Binance WebSocket subscription."""
        with (
            patch("src.exchanges.binance.AsyncClient.create") as mock_create,
            patch("src.exchanges.binance.BinanceSocketManager") as mock_socket_manager,
            patch("src.exchanges.base.get_global_rate_limiter"),
            patch("src.exchanges.base.RedisClient"),
            patch("src.exchanges.base.get_metrics_collector"),
            patch("aiohttp.TCPConnector"),
            patch("aiohttp.ClientSession"),
        ):
            mock_create.return_value = mock_binance_client
            mock_socket = AsyncMock()
            mock_socket_manager.return_value.trade_socket = AsyncMock(return_value=mock_socket)

            from src.exchanges.binance import BinanceExchange

            exchange = BinanceExchange(mock_config)
            await exchange.connect()

            callback = AsyncMock()
            await exchange.subscribe_to_stream("BTCUSDT", callback)

            assert "BTCUSDT_stream" in exchange.active_streams

    @pytest.mark.asyncio
    async def test_coinbase_websocket_subscription(self, mock_config, mock_coinbase_client):
        """Test Coinbase WebSocket subscription."""
        with (
            patch("src.exchanges.coinbase.cbpro.AuthenticatedClient") as mock_client_class,
            patch("src.exchanges.base.get_global_rate_limiter"),
            patch("src.exchanges.base.RedisClient"),
            patch("src.exchanges.base.get_metrics_collector"),
            patch("aiohttp.TCPConnector"),
            patch("aiohttp.ClientSession"),
            patch("websockets.connect") as mock_websocket_connect,
        ):
            mock_client_class.return_value = mock_coinbase_client
            mock_websocket = AsyncMock()
            mock_websocket_connect.return_value = mock_websocket

            from src.exchanges.coinbase import CoinbaseExchange

            exchange = CoinbaseExchange(mock_config)
            await exchange.connect()

            callback = AsyncMock()
            await exchange.subscribe_to_stream("BTC-USD", callback)

            assert "BTC-USD_stream" in exchange.active_streams


class TestExchangeDataProcessing:
    """Test data processing and type conversion."""

    @pytest.mark.asyncio
    async def test_binance_order_type_conversion(self, mock_config, mock_binance_client):
        """Test Binance order type conversion."""
        with (
            patch("src.exchanges.binance.AsyncClient.create") as mock_create,
            patch("src.exchanges.base.get_global_rate_limiter"),
            patch("src.exchanges.base.RedisClient"),
            patch("src.exchanges.base.get_metrics_collector"),
            patch("aiohttp.TCPConnector"),
            patch("aiohttp.ClientSession"),
        ):
            mock_create.return_value = mock_binance_client

            from src.exchanges.binance import BinanceExchange

            exchange = BinanceExchange(mock_config)
            await exchange.connect()

            # Test different order types
            market_order = OrderRequest(
                symbol="BTCUSDT",
                side=OrderSide.BUY,
                order_type=OrderType.MARKET,
                quantity=Decimal("1.0"),
            )

            limit_order = OrderRequest(
                symbol="BTCUSDT",
                side=OrderSide.BUY,
                order_type=OrderType.LIMIT,
                quantity=Decimal("1.0"),
                price=Decimal("50000.0"),
            )

            # Both should work without errors
            await exchange.place_order(market_order)
            await exchange.place_order(limit_order)

            assert mock_binance_client.create_order.call_count == 2

    @pytest.mark.asyncio
    async def test_decimal_precision_handling(self, mock_config, mock_binance_client):
        """Test decimal precision handling across exchanges."""
        with (
            patch("src.exchanges.binance.AsyncClient.create") as mock_create,
            patch("src.exchanges.base.get_global_rate_limiter"),
            patch("src.exchanges.base.RedisClient"),
            patch("src.exchanges.base.get_metrics_collector"),
            patch("aiohttp.TCPConnector"),
            patch("aiohttp.ClientSession"),
        ):
            mock_create.return_value = mock_binance_client

            from src.exchanges.binance import BinanceExchange

            exchange = BinanceExchange(mock_config)
            await exchange.connect()

            # Test high precision decimal
            order = OrderRequest(
                symbol="BTCUSDT",
                side=OrderSide.BUY,
                order_type=OrderType.LIMIT,
                quantity=Decimal("0.00001234"),
                price=Decimal("50000.12345678"),
            )

            response = await exchange.place_order(order)

            # Should handle precision correctly
            assert isinstance(response.quantity, Decimal)
            assert isinstance(response.price, Decimal)


@pytest.mark.asyncio
async def test_comprehensive_multi_exchange_integration(mock_config):
    """Test comprehensive integration across multiple exchanges."""
    with (
        patch("src.exchanges.binance.AsyncClient.create") as mock_binance_create,
        patch("src.exchanges.coinbase.cbpro.AuthenticatedClient") as mock_coinbase_class,
        patch("src.exchanges.okx.okx_client.OKXRestClient") as mock_okx_class,
        patch("src.exchanges.base.get_global_rate_limiter"),
        patch("src.exchanges.base.RedisClient"),
        patch("src.exchanges.base.get_metrics_collector"),
        patch("aiohttp.TCPConnector"),
        patch("aiohttp.ClientSession"),
    ):
        # Configure mocks
        binance_client = AsyncMock()
        coinbase_client = AsyncMock()
        okx_client = AsyncMock()

        mock_binance_create.return_value = binance_client
        mock_coinbase_class.return_value = coinbase_client
        mock_okx_class.return_value = okx_client

        # Configure common responses
        binance_client.get_account.return_value = {
            "balances": [{"asset": "BTC", "free": "1.0", "locked": "0.0"}]
        }
        coinbase_client.get_accounts.return_value = [
            {"currency": "BTC", "balance": "1.0", "available": "1.0"}
        ]
        okx_client.get_account_balance.return_value = {
            "data": [{"details": [{"ccy": "BTC", "availBal": "1.0", "frozenBal": "0.0"}]}]
        }

        # Import exchange classes
        from src.exchanges.binance import BinanceExchange
        from src.exchanges.coinbase import CoinbaseExchange
        from src.exchanges.okx import OKXExchange

        # Create exchanges
        binance = BinanceExchange(mock_config)
        coinbase = CoinbaseExchange(mock_config)
        okx = OKXExchange(mock_config)

        exchanges = [binance, coinbase, okx]

        # 1. Connect all exchanges
        for exchange in exchanges:
            result = await exchange.connect()
            assert result is True

        # 2. Get balances from all exchanges
        balances = []
        for exchange in exchanges:
            balance = await exchange.get_account_balance()
            balances.append(balance)
            assert "BTC" in balance

        # 3. Perform health checks
        for exchange in exchanges:
            health = await exchange.health_check()
            assert health.status == HealthStatus.HEALTHY

        # 4. Disconnect all exchanges
        for exchange in exchanges:
            await exchange.disconnect()
            assert exchange.connected is False


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
