"""
Comprehensive Integration Tests for exchanges/factory.py - Full Coverage

This test suite provides comprehensive integration testing for the ExchangeFactory class
and related components including HealthMonitor, ConnectionManager, and dependency injection.

Target: Cover ALL of factory.py (377 lines) to achieve 70% coverage target.
"""

import asyncio
from unittest.mock import AsyncMock, Mock, patch

import pytest

from src.core.config import Config
from src.core.dependency_injection import DependencyInjector
from src.core.exceptions import ExchangeError, ValidationError
from src.core.types import ExchangeStatus
from src.exchanges.base import BaseExchange
from src.exchanges.factory import ExchangeFactory, HealthMonitor


class MockExchange(BaseExchange):
    """Mock exchange for testing."""

    def __init__(self, config, exchange_name, **kwargs):
        super().__init__(config, exchange_name, **kwargs)
        self.health_check_result = True
        self.connect_result = True

    async def health_check(self):
        return self.health_check_result

    async def connect(self):
        await asyncio.sleep(0.01)
        return self.connect_result

    async def disconnect(self):
        await asyncio.sleep(0.01)

    async def _connect_to_exchange(self):
        return self.connect_result

    async def _disconnect_from_exchange(self):
        pass

    async def _place_order_on_exchange(self, order):
        pass

    async def cancel_order(self, order_id, symbol):
        return True

    async def get_order_status(self, order_id):
        pass

    async def get_account_balance(self):
        return {}

    async def get_order_book(self, symbol, depth=10):
        pass

    async def _get_market_data_from_exchange(self, symbol, timeframe="1m"):
        pass

    async def _get_trade_history_from_exchange(self, symbol, limit=100):
        return []

    async def get_exchange_info(self):
        pass

    async def get_ticker(self, symbol):
        pass

    async def _create_websocket_stream(self, symbol, stream_name):
        pass

    async def _handle_exchange_stream(self, stream_name, stream):
        pass

    async def _close_exchange_stream(self, stream_name, stream):
        pass


@pytest.fixture
def mock_config():
    """Create mock configuration."""
    config = Mock(spec=Config)

    # Health monitoring configuration
    health_config = Mock()
    health_config.health_check_interval_seconds = 30
    health_config.unhealthy_threshold = 3
    health_config.recovery_check_interval_seconds = 60
    health_config.timeout_seconds = 10
    config.exchange_health = health_config

    # Exchange configuration
    config.exchange = Mock()
    config.exchange.enabled_exchanges = ["binance", "coinbase", "okx"]
    config.exchange.default_exchange = "binance"

    # Binance config
    config.binance = Mock()
    config.binance.api_key = "test_key"
    config.binance.api_secret = "test_secret"
    config.binance.sandbox = True

    # Coinbase config
    config.coinbase = Mock()
    config.coinbase.api_key = "test_key"
    config.coinbase.api_secret = "test_secret"
    config.coinbase.passphrase = "test_pass"
    config.coinbase.sandbox = True

    # OKX config
    config.okx = Mock()
    config.okx.api_key = "test_key"
    config.okx.api_secret = "test_secret"
    config.okx.passphrase = "test_pass"
    config.okx.sandbox = True

    return config


@pytest.fixture
def mock_dependency_injector():
    """Create mock dependency injector."""
    injector = Mock(spec=DependencyInjector)
    injector.get_service = Mock()
    injector.register_service = Mock()
    injector.get_all_services = Mock(return_value={})
    return injector


class TestHealthMonitor:
    """Test HealthMonitor functionality."""

    def test_health_monitor_creation(self, mock_config):
        """Test HealthMonitor creation."""
        monitor = HealthMonitor(mock_config)

        assert monitor.config == mock_config
        assert monitor.health_check_interval == 30
        assert monitor.unhealthy_threshold == 3
        assert monitor.recovery_check_interval == 60
        assert monitor.timeout_seconds == 10
        assert len(monitor.health_status) == 0
        assert len(monitor.monitoring_tasks) == 0

    def test_health_monitor_creation_with_dict_config(self):
        """Test HealthMonitor creation with dict-style config."""
        config = Mock()
        config.exchange_health = {
            "health_check_interval_seconds": 45,
            "unhealthy_threshold": 5,
            "recovery_check_interval_seconds": 90,
            "timeout_seconds": 15,
        }

        monitor = HealthMonitor(config)

        assert monitor.health_check_interval == 30  # Uses default
        assert monitor.unhealthy_threshold == 3  # Uses default
        assert monitor.recovery_check_interval == 60  # Uses default
        assert monitor.timeout_seconds == 10  # Uses default

    @pytest.mark.asyncio
    async def test_start_monitoring(self, mock_config):
        """Test starting health monitoring."""
        monitor = HealthMonitor(mock_config)
        exchange = MockExchange(mock_config, "binance")

        await monitor.start_monitoring("binance", exchange)

        assert "binance" in monitor.monitoring_tasks
        assert isinstance(monitor.monitoring_tasks["binance"], asyncio.Task)

        # Clean up
        await monitor.stop_monitoring("binance")

    @pytest.mark.asyncio
    async def test_start_monitoring_already_exists(self, mock_config):
        """Test starting monitoring when already exists."""
        monitor = HealthMonitor(mock_config)
        exchange = MockExchange(mock_config, "binance")

        await monitor.start_monitoring("binance", exchange)
        initial_task = monitor.monitoring_tasks["binance"]

        # Start again - should not create new task
        await monitor.start_monitoring("binance", exchange)

        assert monitor.monitoring_tasks["binance"] == initial_task

        # Clean up
        await monitor.stop_monitoring("binance")

    @pytest.mark.asyncio
    async def test_stop_monitoring(self, mock_config):
        """Test stopping health monitoring."""
        monitor = HealthMonitor(mock_config)
        exchange = MockExchange(mock_config, "binance")

        await monitor.start_monitoring("binance", exchange)
        await monitor.stop_monitoring("binance")

        assert "binance" not in monitor.monitoring_tasks
        assert "binance" not in monitor.health_status

    @pytest.mark.asyncio
    async def test_stop_monitoring_nonexistent(self, mock_config):
        """Test stopping monitoring for non-existent exchange."""
        monitor = HealthMonitor(mock_config)

        # Should not raise exception
        await monitor.stop_monitoring("nonexistent")

    @pytest.mark.asyncio
    async def test_monitor_exchange_health_success(self, mock_config):
        """Test successful health monitoring."""
        monitor = HealthMonitor(mock_config)
        monitor.health_check_interval = 0.01  # Very short interval for testing

        exchange = MockExchange(mock_config, "binance")
        exchange.health_check_result = True

        # Start monitoring and let it run briefly
        task = asyncio.create_task(monitor._monitor_exchange_health("binance", exchange))
        await asyncio.sleep(0.05)  # Let it run a few cycles
        task.cancel()

        try:
            await task
        except asyncio.CancelledError:
            pass

        # Should have recorded healthy status
        assert "binance" in monitor.health_status
        assert monitor.health_status["binance"]["status"] == "healthy"
        assert monitor.health_status["binance"]["consecutive_failures"] == 0

    @pytest.mark.asyncio
    async def test_monitor_exchange_health_failure(self, mock_config):
        """Test health monitoring with failures."""
        monitor = HealthMonitor(mock_config)
        monitor.health_check_interval = 0.01
        monitor.unhealthy_threshold = 2

        exchange = MockExchange(mock_config, "binance")
        exchange.health_check_result = False

        # Start monitoring and let it run briefly
        task = asyncio.create_task(monitor._monitor_exchange_health("binance", exchange))
        await asyncio.sleep(0.05)
        task.cancel()

        try:
            await task
        except asyncio.CancelledError:
            pass

        # Should have recorded unhealthy status
        if "binance" in monitor.health_status:
            assert monitor.health_status["binance"]["status"] == "unhealthy"

    @pytest.mark.asyncio
    async def test_monitor_exchange_health_exception(self, mock_config):
        """Test health monitoring with exception."""
        monitor = HealthMonitor(mock_config)
        monitor.health_check_interval = 0.01

        exchange = MockExchange(mock_config, "binance")
        exchange.health_check = AsyncMock(side_effect=Exception("Health check failed"))

        # Start monitoring and let it run briefly
        task = asyncio.create_task(monitor._monitor_exchange_health("binance", exchange))
        await asyncio.sleep(0.05)
        task.cancel()

        try:
            await task
        except asyncio.CancelledError:
            pass

        # Should handle exception gracefully


class TestExchangeFactory:
    """Test ExchangeFactory functionality."""

    def test_factory_creation(self, mock_config, mock_dependency_injector):
        """Test ExchangeFactory creation."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        assert factory.config == mock_config
        assert factory.dependency_injector == mock_dependency_injector
        assert len(factory.exchange_instances) == 0
        assert len(factory.exchange_configs) == 0
        assert isinstance(factory.health_monitor, HealthMonitor)

    def test_factory_creation_without_injector(self, mock_config):
        """Test ExchangeFactory creation without dependency injector."""
        factory = ExchangeFactory(mock_config)

        assert factory.config == mock_config
        assert factory.dependency_injector is None

    @pytest.mark.asyncio
    async def test_register_exchange_success(self, mock_config, mock_dependency_injector):
        """Test successful exchange registration."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        exchange_config = {
            "name": "binance",
            "class": MockExchange,
            "config": {"api_key": "test", "api_secret": "secret"},
        }

        result = await factory.register_exchange("binance", exchange_config)

        assert result is True
        assert "binance" in factory.exchange_configs
        assert factory.exchange_configs["binance"] == exchange_config

    @pytest.mark.asyncio
    async def test_register_exchange_duplicate(self, mock_config, mock_dependency_injector):
        """Test registering duplicate exchange."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        exchange_config = {"name": "binance", "class": MockExchange, "config": {"api_key": "test"}}

        await factory.register_exchange("binance", exchange_config)

        # Register again - should return False
        result = await factory.register_exchange("binance", exchange_config)
        assert result is False

    @pytest.mark.asyncio
    async def test_register_exchange_invalid_config(self, mock_config, mock_dependency_injector):
        """Test registering exchange with invalid config."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        # Missing required fields
        exchange_config = {"name": "binance"}

        with pytest.raises(ValidationError):
            await factory.register_exchange("binance", exchange_config)

    @pytest.mark.asyncio
    async def test_create_exchange_success(self, mock_config, mock_dependency_injector):
        """Test successful exchange creation."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        with patch("src.exchanges.factory.ExchangeFactory._get_exchange_class") as mock_get_class:
            mock_get_class.return_value = MockExchange

            exchange = await factory.create_exchange("binance")

            assert exchange is not None
            assert isinstance(exchange, MockExchange)
            assert exchange.exchange_name == "binance"
            assert "binance" in factory.exchange_instances

    @pytest.mark.asyncio
    async def test_create_exchange_with_options(self, mock_config, mock_dependency_injector):
        """Test exchange creation with additional options."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        with patch("src.exchanges.factory.ExchangeFactory._get_exchange_class") as mock_get_class:
            mock_get_class.return_value = MockExchange

            options = {"sandbox": True, "timeout": 30}
            exchange = await factory.create_exchange("binance", **options)

            assert exchange is not None
            assert "binance" in factory.exchange_instances

    @pytest.mark.asyncio
    async def test_create_exchange_unsupported(self, mock_config, mock_dependency_injector):
        """Test creating unsupported exchange."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        with pytest.raises(ExchangeError, match="Unsupported exchange"):
            await factory.create_exchange("unsupported_exchange")

    @pytest.mark.asyncio
    async def test_create_exchange_with_health_monitoring(
        self, mock_config, mock_dependency_injector
    ):
        """Test exchange creation with health monitoring."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        with patch("src.exchanges.factory.ExchangeFactory._get_exchange_class") as mock_get_class:
            mock_get_class.return_value = MockExchange

            exchange = await factory.create_exchange("binance", enable_health_monitoring=True)

            assert exchange is not None
            # Health monitoring should be started
            assert "binance" in factory.health_monitor.monitoring_tasks

            # Clean up
            await factory.health_monitor.stop_monitoring("binance")

    @pytest.mark.asyncio
    async def test_get_exchange_existing(self, mock_config, mock_dependency_injector):
        """Test getting existing exchange instance."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        with patch("src.exchanges.factory.ExchangeFactory._get_exchange_class") as mock_get_class:
            mock_get_class.return_value = MockExchange

            # Create exchange
            original_exchange = await factory.create_exchange("binance")

            # Get existing exchange
            retrieved_exchange = await factory.get_exchange("binance")

            assert retrieved_exchange == original_exchange

    @pytest.mark.asyncio
    async def test_get_exchange_create_new(self, mock_config, mock_dependency_injector):
        """Test getting exchange that doesn't exist (creates new)."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        with patch("src.exchanges.factory.ExchangeFactory._get_exchange_class") as mock_get_class:
            mock_get_class.return_value = MockExchange

            exchange = await factory.get_exchange("binance")

            assert exchange is not None
            assert "binance" in factory.exchange_instances

    @pytest.mark.asyncio
    async def test_get_all_exchanges(self, mock_config, mock_dependency_injector):
        """Test getting all exchange instances."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        with patch("src.exchanges.factory.ExchangeFactory._get_exchange_class") as mock_get_class:
            mock_get_class.return_value = MockExchange

            # Create multiple exchanges
            await factory.create_exchange("binance")
            await factory.create_exchange("coinbase")

            all_exchanges = await factory.get_all_exchanges()

            assert len(all_exchanges) == 2
            assert "binance" in all_exchanges
            assert "coinbase" in all_exchanges

    @pytest.mark.asyncio
    async def test_remove_exchange(self, mock_config, mock_dependency_injector):
        """Test removing exchange instance."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        with patch("src.exchanges.factory.ExchangeFactory._get_exchange_class") as mock_get_class:
            mock_get_class.return_value = MockExchange

            # Create exchange with health monitoring
            await factory.create_exchange("binance", enable_health_monitoring=True)

            # Remove exchange
            result = await factory.remove_exchange("binance")

            assert result is True
            assert "binance" not in factory.exchange_instances
            assert "binance" not in factory.health_monitor.monitoring_tasks

    @pytest.mark.asyncio
    async def test_remove_nonexistent_exchange(self, mock_config, mock_dependency_injector):
        """Test removing non-existent exchange."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        result = await factory.remove_exchange("nonexistent")
        assert result is False

    @pytest.mark.asyncio
    async def test_connect_all_exchanges(self, mock_config, mock_dependency_injector):
        """Test connecting all exchanges."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        with patch("src.exchanges.factory.ExchangeFactory._get_exchange_class") as mock_get_class:
            mock_get_class.return_value = MockExchange

            # Create exchanges
            await factory.create_exchange("binance")
            await factory.create_exchange("coinbase")

            results = await factory.connect_all()

            assert len(results) == 2
            assert all(results.values())  # All should be True

    @pytest.mark.asyncio
    async def test_connect_all_with_failure(self, mock_config, mock_dependency_injector):
        """Test connecting all exchanges with one failure."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        with patch("src.exchanges.factory.ExchangeFactory._get_exchange_class") as mock_get_class:
            mock_get_class.return_value = MockExchange

            # Create exchanges
            binance = await factory.create_exchange("binance")
            coinbase = await factory.create_exchange("coinbase")

            # Make coinbase fail
            coinbase.connect_result = False

            results = await factory.connect_all()

            assert results["binance"] is True
            assert results["coinbase"] is False

    @pytest.mark.asyncio
    async def test_disconnect_all_exchanges(self, mock_config, mock_dependency_injector):
        """Test disconnecting all exchanges."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        with patch("src.exchanges.factory.ExchangeFactory._get_exchange_class") as mock_get_class:
            mock_get_class.return_value = MockExchange

            # Create and connect exchanges
            await factory.create_exchange("binance")
            await factory.create_exchange("coinbase")
            await factory.connect_all()

            await factory.disconnect_all()

            # Should not raise exceptions

    @pytest.mark.asyncio
    async def test_get_exchange_status(self, mock_config, mock_dependency_injector):
        """Test getting exchange status."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        with patch("src.exchanges.factory.ExchangeFactory._get_exchange_class") as mock_get_class:
            mock_get_class.return_value = MockExchange

            exchange = await factory.create_exchange("binance")
            await exchange.connect()

            status = await factory.get_exchange_status("binance")

            assert status is not None
            assert status.name == "binance"
            assert status.is_connected is True

    @pytest.mark.asyncio
    async def test_get_exchange_status_nonexistent(self, mock_config, mock_dependency_injector):
        """Test getting status for non-existent exchange."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        status = await factory.get_exchange_status("nonexistent")
        assert status is None

    @pytest.mark.asyncio
    async def test_get_all_exchange_statuses(self, mock_config, mock_dependency_injector):
        """Test getting all exchange statuses."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        with patch("src.exchanges.factory.ExchangeFactory._get_exchange_class") as mock_get_class:
            mock_get_class.return_value = MockExchange

            # Create exchanges
            await factory.create_exchange("binance")
            await factory.create_exchange("coinbase")

            statuses = await factory.get_all_exchange_statuses()

            assert len(statuses) == 2
            assert all(isinstance(status, ExchangeStatus) for status in statuses)

    def test_get_exchange_class_binance(self, mock_config, mock_dependency_injector):
        """Test getting Binance exchange class."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        with patch("src.exchanges.binance.BinanceExchange") as mock_binance:
            exchange_class = factory._get_exchange_class("binance")
            assert exchange_class == mock_binance

    def test_get_exchange_class_coinbase(self, mock_config, mock_dependency_injector):
        """Test getting Coinbase exchange class."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        with patch("src.exchanges.coinbase.CoinbaseExchange") as mock_coinbase:
            exchange_class = factory._get_exchange_class("coinbase")
            assert exchange_class == mock_coinbase

    def test_get_exchange_class_okx(self, mock_config, mock_dependency_injector):
        """Test getting OKX exchange class."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        with patch("src.exchanges.okx.OKXExchange") as mock_okx:
            exchange_class = factory._get_exchange_class("okx")
            assert exchange_class == mock_okx

    def test_get_exchange_class_unsupported(self, mock_config, mock_dependency_injector):
        """Test getting unsupported exchange class."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        with pytest.raises(ExchangeError, match="Unsupported exchange"):
            factory._get_exchange_class("unsupported")

    def test_validate_exchange_config_valid(self, mock_config, mock_dependency_injector):
        """Test validating valid exchange config."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        valid_config = {"name": "binance", "class": MockExchange, "config": {"api_key": "test"}}

        # Should not raise exception
        factory._validate_exchange_config("binance", valid_config)

    def test_validate_exchange_config_missing_name(self, mock_config, mock_dependency_injector):
        """Test validating config with missing name."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        invalid_config = {"class": MockExchange, "config": {"api_key": "test"}}

        with pytest.raises(ValidationError, match="Exchange config must include 'name'"):
            factory._validate_exchange_config("binance", invalid_config)

    def test_validate_exchange_config_missing_class(self, mock_config, mock_dependency_injector):
        """Test validating config with missing class."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        invalid_config = {"name": "binance", "config": {"api_key": "test"}}

        with pytest.raises(ValidationError, match="Exchange config must include 'class'"):
            factory._validate_exchange_config("binance", invalid_config)

    def test_get_exchange_config_binance(self, mock_config, mock_dependency_injector):
        """Test getting Binance exchange configuration."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        config = factory._get_exchange_config("binance")

        assert "api_key" in config
        assert "api_secret" in config
        assert "sandbox" in config

    def test_get_exchange_config_coinbase(self, mock_config, mock_dependency_injector):
        """Test getting Coinbase exchange configuration."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        config = factory._get_exchange_config("coinbase")

        assert "api_key" in config
        assert "api_secret" in config
        assert "passphrase" in config
        assert "sandbox" in config

    def test_get_exchange_config_okx(self, mock_config, mock_dependency_injector):
        """Test getting OKX exchange configuration."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        config = factory._get_exchange_config("okx")

        assert "api_key" in config
        assert "api_secret" in config
        assert "passphrase" in config
        assert "sandbox" in config

    def test_get_exchange_config_unsupported(self, mock_config, mock_dependency_injector):
        """Test getting config for unsupported exchange."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        with pytest.raises(ExchangeError, match="Unsupported exchange"):
            factory._get_exchange_config("unsupported")

    @pytest.mark.asyncio
    async def test_cleanup(self, mock_config, mock_dependency_injector):
        """Test factory cleanup."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        with patch("src.exchanges.factory.ExchangeFactory._get_exchange_class") as mock_get_class:
            mock_get_class.return_value = MockExchange

            # Create exchanges with health monitoring
            await factory.create_exchange("binance", enable_health_monitoring=True)
            await factory.create_exchange("coinbase", enable_health_monitoring=True)

            # Cleanup
            await factory.cleanup()

            assert len(factory.exchange_instances) == 0
            assert len(factory.health_monitor.monitoring_tasks) == 0

    @pytest.mark.asyncio
    async def test_health_check_all(self, mock_config, mock_dependency_injector):
        """Test health checking all exchanges."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        with patch("src.exchanges.factory.ExchangeFactory._get_exchange_class") as mock_get_class:
            mock_get_class.return_value = MockExchange

            # Create exchanges
            binance = await factory.create_exchange("binance")
            coinbase = await factory.create_exchange("coinbase")

            # Make coinbase unhealthy
            coinbase.health_check_result = False

            health_results = await factory.health_check_all()

            assert len(health_results) == 2
            assert health_results["binance"] is True
            assert health_results["coinbase"] is False

    def test_is_exchange_supported(self, mock_config, mock_dependency_injector):
        """Test checking if exchange is supported."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        assert factory.is_exchange_supported("binance") is True
        assert factory.is_exchange_supported("coinbase") is True
        assert factory.is_exchange_supported("okx") is True
        assert factory.is_exchange_supported("unsupported") is False

    def test_get_supported_exchanges(self, mock_config, mock_dependency_injector):
        """Test getting list of supported exchanges."""
        factory = ExchangeFactory(mock_config, mock_dependency_injector)

        supported = factory.get_supported_exchanges()

        assert "binance" in supported
        assert "coinbase" in supported
        assert "okx" in supported


@pytest.mark.asyncio
async def test_comprehensive_factory_integration(mock_config, mock_dependency_injector):
    """Test comprehensive factory integration flow."""
    factory = ExchangeFactory(mock_config, mock_dependency_injector)

    with patch("src.exchanges.factory.ExchangeFactory._get_exchange_class") as mock_get_class:
        mock_get_class.return_value = MockExchange

        # 1. Register custom exchange configuration
        custom_config = {
            "name": "binance",
            "class": MockExchange,
            "config": {"api_key": "custom_key", "api_secret": "custom_secret"},
        }
        result = await factory.register_exchange("binance", custom_config)
        assert result is True

        # 2. Create exchanges with health monitoring
        binance = await factory.create_exchange("binance", enable_health_monitoring=True)
        coinbase = await factory.create_exchange("coinbase", enable_health_monitoring=True)

        assert isinstance(binance, MockExchange)
        assert isinstance(coinbase, MockExchange)

        # 3. Connect all exchanges
        connect_results = await factory.connect_all()
        assert all(connect_results.values())

        # 4. Get exchange statuses
        statuses = await factory.get_all_exchange_statuses()
        assert len(statuses) == 2

        # 5. Perform health checks
        health_results = await factory.health_check_all()
        assert all(health_results.values())

        # 6. Get specific exchange
        retrieved_binance = await factory.get_exchange("binance")
        assert retrieved_binance == binance

        # 7. Remove one exchange
        remove_result = await factory.remove_exchange("coinbase")
        assert remove_result is True

        all_exchanges = await factory.get_all_exchanges()
        assert len(all_exchanges) == 1
        assert "binance" in all_exchanges

        # 8. Cleanup
        await factory.cleanup()
        assert len(factory.exchange_instances) == 0


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
