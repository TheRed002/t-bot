"""
Comprehensive Integration Tests for exchanges/base.py - Full Coverage

This test suite provides comprehensive integration testing for the EnhancedBaseExchange class,
covering all major components including connection management, order management, WebSocket
handling, rate limiting, state management, and error handling.

Target: Cover ALL of base.py (761 lines) to achieve 70% coverage target.
"""

import asyncio
import time
from datetime import datetime, timezone
from decimal import Decimal
from unittest.mock import AsyncMock, Mock, patch

import pytest

from src.core.base.interfaces import HealthStatus
from src.core.config import Config
from src.core.exceptions import (
    ExchangeConnectionError,
    OrderRejectionError,
    ValidationError,
)
from src.core.types import (
    ExchangeInfo,
    MarketData,
    OrderBook,
    OrderRequest,
    OrderResponse,
    OrderSide,
    OrderStatus,
    OrderType,
    Ticker,
    Trade,
)
from src.exchanges.base import EnhancedBaseExchange


class MockExchange(EnhancedBaseExchange):
    """Mock exchange implementation for testing."""

    def __init__(self, config: Config, exchange_name: str = "mock_exchange", **kwargs):
        super().__init__(config, exchange_name, **kwargs)
        self.mock_data = {}
        self.connection_success = True
        self.order_responses = {}
        self.market_data_responses = {}
        self.balance_responses = {}

    async def _connect_to_exchange(self) -> bool:
        """Mock exchange connection."""
        await asyncio.sleep(0.01)  # Simulate network delay
        if self.connection_success:
            self.mock_data["connection_time"] = datetime.now(timezone.utc)
            return True
        return False

    async def _disconnect_from_exchange(self) -> None:
        """Mock exchange disconnection."""
        await asyncio.sleep(0.01)
        self.mock_data["disconnection_time"] = datetime.now(timezone.utc)

    async def _place_order_on_exchange(self, order: OrderRequest) -> OrderResponse:
        """Mock order placement."""
        if order.symbol == "FAIL":
            raise OrderRejectionError("Mock order rejection")

        order_id = f"mock_{int(time.time() * 1000)}"
        response = OrderResponse(
            id=order_id,
            symbol=order.symbol,
            side=order.side,
            order_type=order.order_type,
            quantity=order.quantity,
            price=order.price,
            status=OrderStatus.FILLED,
            filled_quantity=order.quantity,
            average_price=order.price or Decimal("100.0"),
            created_at=datetime.now(timezone.utc),
        )
        self.order_responses[order_id] = response
        return response

    async def cancel_order(self, order_id: str, symbol: str) -> bool:
        """Mock order cancellation."""
        if order_id in self.order_responses:
            self.order_responses[order_id].status = OrderStatus.CANCELLED
            return True
        return False

    async def get_order_status(self, order_id: str) -> OrderStatus:
        """Mock order status check."""
        if order_id in self.order_responses:
            return self.order_responses[order_id].status
        return OrderStatus.REJECTED

    async def get_account_balance(self) -> dict[str, Decimal]:
        """Mock account balance."""
        return {"BTC": Decimal("1.0"), "USDT": Decimal("10000.0")}

    async def get_order_book(self, symbol: str, depth: int = 10) -> OrderBook:
        """Mock order book."""
        return OrderBook(
            symbol=symbol,
            bids=[(Decimal("99.0"), Decimal("1.0"))],
            asks=[(Decimal("101.0"), Decimal("1.0"))],
            timestamp=datetime.now(timezone.utc),
        )

    async def _get_market_data_from_exchange(
        self, symbol: str, timeframe: str = "1m"
    ) -> MarketData:
        """Mock market data."""
        if symbol in self.market_data_responses:
            return self.market_data_responses[symbol]

        return MarketData(
            symbol=symbol,
            price=Decimal("100.0"),
            volume=Decimal("1000.0"),
            timestamp=datetime.now(timezone.utc),
            open_price=Decimal("99.0"),
            high_price=Decimal("102.0"),
            low_price=Decimal("98.0"),
        )

    async def _get_trade_history_from_exchange(self, symbol: str, limit: int = 100) -> list[Trade]:
        """Mock trade history."""
        return [
            Trade(
                id="trade_1",
                symbol=symbol,
                price=Decimal("100.0"),
                quantity=Decimal("1.0"),
                side=OrderSide.BUY,
                timestamp=datetime.now(timezone.utc),
            )
        ]

    async def get_exchange_info(self) -> ExchangeInfo:
        """Mock exchange info."""
        return ExchangeInfo(
            name="mock_exchange",
            symbols=["BTCUSDT", "ETHUSDT"],
            trading_fees={"maker": Decimal("0.001"), "taker": Decimal("0.001")},
            min_trade_amounts={"BTCUSDT": Decimal("0.001")},
        )

    async def get_ticker(self, symbol: str) -> Ticker:
        """Mock ticker."""
        return Ticker(
            symbol=symbol,
            price=Decimal("100.0"),
            bid=Decimal("99.0"),
            ask=Decimal("101.0"),
            volume=Decimal("1000.0"),
            timestamp=datetime.now(timezone.utc),
        )

    async def _create_websocket_stream(self, symbol: str, stream_name: str):
        """Mock WebSocket stream creation."""
        return {"symbol": symbol, "stream_name": stream_name, "connected": True}

    async def _handle_exchange_stream(self, stream_name: str, stream):
        """Mock stream handling."""
        await asyncio.sleep(0.01)

    async def _close_exchange_stream(self, stream_name: str, stream):
        """Mock stream closure."""
        await asyncio.sleep(0.01)


@pytest.fixture
async def mock_config():
    """Create mock configuration."""
    config = Mock(spec=Config)
    config.exchange = Mock()
    config.exchange.get_connection_pool_config = Mock(
        return_value={
            "max_pool_size": 100,
            "pool_size": 30,
            "keepalive_timeout": 60,
            "request_timeout": 30,
            "connection_timeout": 10,
        }
    )
    config.exchange.rate_limits = {"mock_exchange": {"place_order": {"max_requests": 10}}}
    return config


@pytest.fixture
async def mock_state_service():
    """Create mock state service."""
    state_service = AsyncMock()
    state_service.set_state = AsyncMock(return_value=True)
    state_service.get_state = AsyncMock(return_value={"status": "filled"})
    return state_service


@pytest.fixture
async def mock_trade_lifecycle_manager():
    """Create mock trade lifecycle manager."""
    manager = AsyncMock()
    manager.update_trade_event = AsyncMock(return_value=True)
    return manager


@pytest.fixture
async def mock_exchange(mock_config, mock_state_service, mock_trade_lifecycle_manager):
    """Create mock exchange instance."""
    with (
        patch("src.exchanges.advanced_rate_limiter.get_global_rate_limiter"),
        patch("src.database.redis_client.RedisClient"),
        patch("src.monitoring.services.get_metrics_collector"),
        patch("aiohttp.TCPConnector"),
        patch("aiohttp.ClientSession"),
    ):
        exchange = MockExchange(
            config=mock_config,
            exchange_name="test_exchange",
            state_service=mock_state_service,
            trade_lifecycle_manager=mock_trade_lifecycle_manager,
        )
        yield exchange
        # Cleanup
        if hasattr(exchange, "cleanup"):
            exchange.cleanup()


class TestEnhancedBaseExchangeConnection:
    """Test connection management functionality."""

    @pytest.mark.asyncio
    async def test_successful_connection(self, mock_exchange):
        """Test successful connection establishment."""
        result = await mock_exchange.connect()

        assert result is True
        assert mock_exchange.connected is True
        assert mock_exchange.status == "connected"
        assert mock_exchange.last_heartbeat is not None

    @pytest.mark.asyncio
    async def test_connection_failure(self, mock_exchange):
        """Test connection failure handling."""
        mock_exchange.connection_success = False

        result = await mock_exchange.connect()

        assert result is False
        assert mock_exchange.connected is False
        assert mock_exchange.status == "connection_failed"

    @pytest.mark.asyncio
    async def test_connection_with_exception(self, mock_exchange):
        """Test connection with exception handling."""
        with patch.object(
            mock_exchange, "_connect_to_exchange", side_effect=Exception("Connection error")
        ):
            result = await mock_exchange.connect()

            assert result is False
            assert mock_exchange.connected is False
            assert mock_exchange.status == "connection_error"

    @pytest.mark.asyncio
    async def test_disconnect(self, mock_exchange):
        """Test disconnection functionality."""
        await mock_exchange.connect()
        await mock_exchange.disconnect()

        assert mock_exchange.connected is False
        assert mock_exchange.status == "disconnected"

    @pytest.mark.asyncio
    async def test_connection_infrastructure_initialization(self, mock_exchange):
        """Test connection infrastructure initialization."""
        with patch.object(mock_exchange, "_initialize_connection_infrastructure") as mock_init:
            mock_init.return_value = None
            await mock_exchange.connect()

            mock_init.assert_called_once()


class TestEnhancedBaseExchangeRateLimiting:
    """Test rate limiting functionality."""

    @pytest.mark.asyncio
    async def test_rate_limit_check_success(self, mock_exchange):
        """Test successful rate limit check."""
        await mock_exchange.connect()

        result = await mock_exchange._check_unified_rate_limit("test_endpoint", 1)
        assert result is True

    @pytest.mark.asyncio
    async def test_rate_limit_validation_error(self, mock_exchange):
        """Test rate limit validation errors."""
        await mock_exchange.connect()

        with pytest.raises(ValidationError, match="Endpoint is required"):
            await mock_exchange._check_unified_rate_limit("", 1)

        with pytest.raises(ValidationError, match="Weight must be positive"):
            await mock_exchange._check_unified_rate_limit("test", 0)

    @pytest.mark.asyncio
    async def test_local_rate_limit_check(self, mock_exchange):
        """Test local rate limit checking."""
        mock_exchange._rate_limit_lock = asyncio.Lock()
        mock_exchange.unified_rate_limiter = {}

        result = await mock_exchange._check_local_rate_limit("test_endpoint", 1)
        assert result is True

    @pytest.mark.asyncio
    async def test_rate_limit_tracking_update(self, mock_exchange):
        """Test rate limit tracking updates."""
        mock_exchange._rate_limit_lock = asyncio.Lock()
        mock_exchange.session_manager = {"request_count": 0, "last_request": None}

        await mock_exchange._update_rate_limit_tracking("test_endpoint", 2)

        assert len(mock_exchange.rate_limit_windows["test_endpoint"]) == 2
        assert mock_exchange.session_manager["request_count"] == 2


class TestEnhancedBaseExchangeOrderManagement:
    """Test order management functionality."""

    @pytest.mark.asyncio
    async def test_successful_order_placement(self, mock_exchange):
        """Test successful order placement."""
        await mock_exchange.connect()

        order = OrderRequest(
            symbol="BTCUSDT",
            side=OrderSide.BUY,
            order_type=OrderType.MARKET,
            quantity=Decimal("1.0"),
        )

        response = await mock_exchange.place_order(order)

        assert response.symbol == "BTCUSDT"
        assert response.status == OrderStatus.FILLED
        assert response.filled_quantity == Decimal("1.0")

    @pytest.mark.asyncio
    async def test_order_validation_failure(self, mock_exchange):
        """Test order validation failure."""
        await mock_exchange.connect()

        order = OrderRequest(
            symbol="",  # Invalid symbol
            side=OrderSide.BUY,
            order_type=OrderType.MARKET,
            quantity=Decimal("1.0"),
        )

        with pytest.raises(ValidationError):
            await mock_exchange.place_order(order)

    @pytest.mark.asyncio
    async def test_order_rejection_handling(self, mock_exchange):
        """Test order rejection handling."""
        await mock_exchange.connect()

        order = OrderRequest(
            symbol="FAIL",  # This triggers rejection in mock
            side=OrderSide.BUY,
            order_type=OrderType.MARKET,
            quantity=Decimal("1.0"),
        )

        with pytest.raises(OrderRejectionError):
            await mock_exchange.place_order(order)

    @pytest.mark.asyncio
    async def test_unified_order_status_check(self, mock_exchange):
        """Test unified order status checking."""
        await mock_exchange.connect()

        # Place an order first
        order = OrderRequest(
            symbol="BTCUSDT",
            side=OrderSide.BUY,
            order_type=OrderType.MARKET,
            quantity=Decimal("1.0"),
        )
        response = await mock_exchange.place_order(order)

        # Check status
        status = await mock_exchange.get_unified_order_status(response.id)
        assert status == OrderStatus.FILLED


class TestEnhancedBaseExchangeStateManagement:
    """Test state management functionality."""

    @pytest.mark.asyncio
    async def test_save_order_to_state(self, mock_exchange):
        """Test saving order to state service."""
        await mock_exchange.connect()

        order_data = {"order_id": "test_123", "symbol": "BTCUSDT", "status": "filled"}

        result = await mock_exchange._save_order_to_state("test_123", order_data)
        assert result is True
        assert "test_123" in mock_exchange.pending_orders

    @pytest.mark.asyncio
    async def test_save_order_without_state_service(self, mock_config):
        """Test saving order without state service."""
        with (
            patch("src.exchanges.advanced_rate_limiter.get_global_rate_limiter"),
            patch("src.database.redis_client.RedisClient"),
            patch("src.monitoring.services.get_metrics_collector"),
        ):
            exchange = MockExchange(config=mock_config, exchange_name="test")
            exchange.state_service = None

            order_data = {"order_id": "test_123", "status": "filled"}
            result = await exchange._save_order_to_state("test_123", order_data)

            assert result is True
            assert "test_123" in exchange.pending_orders

    @pytest.mark.asyncio
    async def test_update_order_state(self, mock_exchange):
        """Test updating order state."""
        await mock_exchange.connect()

        # First save an order
        initial_data = {"order_id": "test_123", "status": "pending"}
        await mock_exchange._save_order_to_state("test_123", initial_data)

        # Then update it
        updates = {"status": "filled", "filled_quantity": "1.0"}
        result = await mock_exchange._update_order_state("test_123", updates)

        assert result is True
        assert mock_exchange.pending_orders["test_123"]["status"] == "filled"

    @pytest.mark.asyncio
    async def test_get_order_from_state(self, mock_exchange):
        """Test getting order from state."""
        await mock_exchange.connect()

        # Save order first
        order_data = {"order_id": "test_123", "status": "filled"}
        await mock_exchange._save_order_to_state("test_123", order_data)

        # Get it back
        retrieved_data = await mock_exchange._get_order_from_state("test_123")
        assert retrieved_data == order_data

    @pytest.mark.asyncio
    async def test_notify_trade_lifecycle(self, mock_exchange):
        """Test trade lifecycle notifications."""
        await mock_exchange.connect()

        order_data = {"order_id": "test_123", "symbol": "BTCUSDT"}

        await mock_exchange._notify_trade_lifecycle("test_123", "order_placed", order_data)

        # Verify the trade lifecycle manager was called
        mock_exchange.trade_lifecycle_manager.update_trade_event.assert_called_once()


class TestEnhancedBaseExchangeMarketData:
    """Test market data functionality."""

    @pytest.mark.asyncio
    async def test_get_market_data(self, mock_exchange):
        """Test getting market data."""
        await mock_exchange.connect()

        market_data = await mock_exchange.get_market_data("BTCUSDT")

        assert market_data.symbol == "BTCUSDT"
        assert market_data.price == Decimal("100.0")
        assert market_data.volume == Decimal("1000.0")

    @pytest.mark.asyncio
    async def test_market_data_caching(self, mock_exchange):
        """Test market data caching."""
        await mock_exchange.connect()

        # First call
        data1 = await mock_exchange.get_market_data("BTCUSDT")

        # Second call should use cache
        data2 = await mock_exchange.get_market_data("BTCUSDT")

        assert data1.symbol == data2.symbol

    @pytest.mark.asyncio
    async def test_cache_market_data_unified(self, mock_exchange):
        """Test unified market data caching."""
        await mock_exchange.connect()

        market_data = MarketData(
            symbol="ETHUSDT",
            price=Decimal("200.0"),
            volume=Decimal("500.0"),
            timestamp=datetime.now(timezone.utc),
        )

        await mock_exchange._cache_market_data_unified("ETHUSDT_1m", market_data)

        assert "ETHUSDT_1m" in mock_exchange.market_data_cache

    @pytest.mark.asyncio
    async def test_get_cached_market_data(self, mock_exchange):
        """Test getting cached market data."""
        await mock_exchange.connect()

        # Cache some data
        market_data = MarketData(
            symbol="ETHUSDT",
            price=Decimal("200.0"),
            volume=Decimal("500.0"),
            timestamp=datetime.now(timezone.utc),
        )
        await mock_exchange._cache_market_data_unified("ETHUSDT_1m", market_data)

        # Retrieve from cache
        cached_data = await mock_exchange._get_cached_market_data("ETHUSDT_1m")
        assert cached_data is not None
        assert cached_data.symbol == "ETHUSDT"


class TestEnhancedBaseExchangeWebSocket:
    """Test WebSocket functionality."""

    @pytest.mark.asyncio
    async def test_subscribe_to_stream(self, mock_exchange):
        """Test WebSocket stream subscription."""
        await mock_exchange.connect()

        callback = AsyncMock()
        await mock_exchange.subscribe_to_stream("BTCUSDT", callback)

        assert "BTCUSDT_stream" in mock_exchange.active_streams
        assert "BTCUSDT_stream" in mock_exchange.stream_callbacks

    @pytest.mark.asyncio
    async def test_close_stream(self, mock_exchange):
        """Test WebSocket stream closure."""
        await mock_exchange.connect()

        # First subscribe
        callback = AsyncMock()
        await mock_exchange.subscribe_to_stream("BTCUSDT", callback)

        # Then close
        await mock_exchange._close_stream("BTCUSDT_stream")

        assert "BTCUSDT_stream" not in mock_exchange.active_streams

    @pytest.mark.asyncio
    async def test_close_all_streams(self, mock_exchange):
        """Test closing all WebSocket streams."""
        await mock_exchange.connect()

        # Subscribe to multiple streams
        callback = AsyncMock()
        await mock_exchange.subscribe_to_stream("BTCUSDT", callback)
        await mock_exchange.subscribe_to_stream("ETHUSDT", callback)

        # Close all
        await mock_exchange._close_all_streams()

        assert len(mock_exchange.active_streams) == 0
        assert len(mock_exchange.stream_callbacks) == 0


class TestEnhancedBaseExchangeHealthMonitoring:
    """Test health monitoring functionality."""

    @pytest.mark.asyncio
    async def test_health_check(self, mock_exchange):
        """Test health check functionality."""
        await mock_exchange.connect()

        health = await mock_exchange.health_check()

        assert health.status == HealthStatus.HEALTHY
        assert mock_exchange.last_heartbeat is not None

    @pytest.mark.asyncio
    async def test_health_check_failure(self, mock_exchange):
        """Test health check failure handling."""
        await mock_exchange.connect()

        with patch.object(mock_exchange, "get_account_balance", side_effect=Exception("API Error")):
            health = await mock_exchange.health_check()
            assert health.status == HealthStatus.UNHEALTHY

    @pytest.mark.asyncio
    async def test_unified_connection_health(self, mock_exchange):
        """Test unified connection health reporting."""
        await mock_exchange.connect()

        health_data = await mock_exchange.get_unified_connection_health()

        assert health_data["exchange"] == "test_exchange"
        assert health_data["connected"] is True
        assert health_data["status"] == "connected"
        assert "active_streams" in health_data
        assert "pending_orders" in health_data


class TestEnhancedBaseExchangeErrorHandling:
    """Test error handling functionality."""

    @pytest.mark.asyncio
    async def test_handle_exchange_error(self, mock_exchange):
        """Test exchange error handling."""
        await mock_exchange.connect()

        error = ExchangeConnectionError("Connection lost")
        context = {"symbol": "BTCUSDT", "order_id": "123"}

        # This should not raise an exception
        await mock_exchange._handle_exchange_error(error, "place_order", context)

    @pytest.mark.asyncio
    async def test_handle_validation_error(self, mock_exchange):
        """Test validation error handling."""
        await mock_exchange.connect()

        error = ValidationError("Invalid order")

        await mock_exchange._handle_exchange_error(error, "validate_order")


class TestEnhancedBaseExchangeUtilities:
    """Test utility methods."""

    @pytest.mark.asyncio
    async def test_pre_trade_validation_success(self, mock_exchange):
        """Test successful pre-trade validation."""
        order = OrderRequest(
            symbol="BTCUSDT",
            side=OrderSide.BUY,
            order_type=OrderType.MARKET,
            quantity=Decimal("1.0"),
        )

        result = await mock_exchange.pre_trade_validation(order)
        assert result is True

    @pytest.mark.asyncio
    async def test_pre_trade_validation_failure(self, mock_exchange):
        """Test pre-trade validation failure."""
        order = OrderRequest(
            symbol="",  # Invalid
            side=OrderSide.BUY,
            order_type=OrderType.MARKET,
            quantity=Decimal("0"),  # Invalid
        )

        result = await mock_exchange.pre_trade_validation(order)
        assert result is False

    @pytest.mark.asyncio
    async def test_post_trade_processing(self, mock_exchange):
        """Test post-trade processing."""
        response = OrderResponse(
            id="test_123",
            symbol="BTCUSDT",
            side=OrderSide.BUY,
            order_type=OrderType.MARKET,
            quantity=Decimal("1.0"),
            status=OrderStatus.FILLED,
            filled_quantity=Decimal("1.0"),
            created_at=datetime.now(timezone.utc),
        )

        # Should not raise exception
        await mock_exchange.post_trade_processing(response)

    @pytest.mark.asyncio
    async def test_validate_trade_data(self, mock_exchange):
        """Test trade data validation."""
        valid_response = OrderResponse(
            id="test_123",
            symbol="BTCUSDT",
            side=OrderSide.BUY,
            order_type=OrderType.MARKET,
            quantity=Decimal("1.0"),
            status=OrderStatus.FILLED,
            filled_quantity=Decimal("1.0"),
            created_at=datetime.now(timezone.utc),
        )

        assert mock_exchange._validate_trade_data(valid_response) is True

        # Test invalid data
        invalid_response = OrderResponse(
            id="",  # Invalid
            symbol="BTCUSDT",
            side=OrderSide.BUY,
            order_type=OrderType.MARKET,
            quantity=Decimal("1.0"),
            status=OrderStatus.FILLED,
            filled_quantity=Decimal("0"),  # Invalid
            created_at=datetime.now(timezone.utc),
        )

        assert mock_exchange._validate_trade_data(invalid_response) is False


class TestEnhancedBaseExchangeContextManagers:
    """Test context manager functionality."""

    @pytest.mark.asyncio
    async def test_async_context_manager(self, mock_exchange):
        """Test async context manager functionality."""
        async with mock_exchange as exchange:
            assert exchange.connected is True
            assert exchange.status == "connected"

        # After exit, should be disconnected
        assert exchange.connected is False
        assert exchange.status == "disconnected"


class TestEnhancedBaseExchangeProperties:
    """Test property methods and status checks."""

    def test_is_connected(self, mock_exchange):
        """Test connection status check."""
        assert mock_exchange.is_connected() is False

        mock_exchange.connected = True
        mock_exchange.status = "connected"
        assert mock_exchange.is_connected() is True

    def test_get_status(self, mock_exchange):
        """Test status getter."""
        assert mock_exchange.get_status() == "initializing"

        mock_exchange.status = "connected"
        assert mock_exchange.get_status() == "connected"

    def test_exchange_name_property(self, mock_exchange):
        """Test exchange name property."""
        assert mock_exchange.exchange_name == "test_exchange"

        mock_exchange.exchange_name = "new_name"
        assert mock_exchange.exchange_name == "new_name"

    def test_get_rate_limits(self, mock_exchange):
        """Test rate limits getter."""
        rate_limits = mock_exchange.get_rate_limits()
        assert isinstance(rate_limits, dict)


class TestEnhancedBaseExchangeCleanup:
    """Test cleanup functionality."""

    def test_cleanup_method(self, mock_exchange):
        """Test cleanup method."""
        mock_exchange.connected = True
        mock_exchange.market_data_cache["test"] = "data"
        mock_exchange.pending_orders["order1"] = "data"

        mock_exchange.cleanup()

        assert len(mock_exchange.market_data_cache) == 0
        assert len(mock_exchange.pending_orders) == 0


class TestEnhancedBaseExchangeAbstractMethods:
    """Test that abstract methods are properly implemented."""

    @pytest.mark.asyncio
    async def test_abstract_methods_implemented(self, mock_exchange):
        """Test that all abstract methods are implemented."""
        await mock_exchange.connect()

        # Test all abstract methods work
        balance = await mock_exchange.get_account_balance()
        assert isinstance(balance, dict)

        order_book = await mock_exchange.get_order_book("BTCUSDT")
        assert isinstance(order_book, OrderBook)

        trades = await mock_exchange.get_trade_history("BTCUSDT")
        assert isinstance(trades, list)

        exchange_info = await mock_exchange.get_exchange_info()
        assert isinstance(exchange_info, ExchangeInfo)

        ticker = await mock_exchange.get_ticker("BTCUSDT")
        assert isinstance(ticker, Ticker)


@pytest.mark.asyncio
async def test_comprehensive_integration_flow(mock_exchange):
    """Test comprehensive integration flow covering multiple components."""
    # 1. Connect to exchange
    await mock_exchange.connect()
    assert mock_exchange.is_connected()

    # 2. Subscribe to data stream
    callback = AsyncMock()
    await mock_exchange.subscribe_to_stream("BTCUSDT", callback)

    # 3. Get market data
    market_data = await mock_exchange.get_market_data("BTCUSDT")
    assert market_data.symbol == "BTCUSDT"

    # 4. Place an order
    order = OrderRequest(
        symbol="BTCUSDT", side=OrderSide.BUY, order_type=OrderType.MARKET, quantity=Decimal("1.0")
    )
    response = await mock_exchange.place_order(order)
    assert response.status == OrderStatus.FILLED

    # 5. Check order status
    status = await mock_exchange.get_unified_order_status(response.id)
    assert status == OrderStatus.FILLED

    # 6. Get account balance
    balance = await mock_exchange.get_account_balance()
    assert "BTC" in balance

    # 7. Perform health check
    health = await mock_exchange.health_check()
    assert health.status == HealthStatus.HEALTHY

    # 8. Close streams and disconnect
    await mock_exchange._close_all_streams()
    await mock_exchange.disconnect()
    assert not mock_exchange.is_connected()


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
