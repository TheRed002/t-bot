"""
Comprehensive functional tests for PortfolioAllocator to achieve maximum coverage.
Tests all major functionality including strategy allocation, rebalancing, and optimization.
"""

import asyncio
from datetime import datetime, timedelta, timezone
from decimal import Decimal
from unittest.mock import AsyncMock, Mock, patch

import numpy as np
import pytest

from src.core.exceptions import AllocationError
from src.core.types import MarketRegime, Signal, SignalDirection, StrategyStatus, StrategyType
from src.strategies.portfolio_allocator import PortfolioAllocator, StrategyAllocation


class TestStrategyAllocation:
    """Test StrategyAllocation class functionality."""
    
    def test_strategy_allocation_initialization(self):
        """Test StrategyAllocation initialization."""
        mock_strategy = Mock()
        mock_strategy.name = "test_strategy"
        
        allocation = StrategyAllocation(
            strategy=mock_strategy,
            target_weight=0.3,
            current_weight=0.25,
            allocated_capital=Decimal("10000"),
            max_allocation=0.4,
            min_allocation=0.05
        )
        
        assert allocation.strategy == mock_strategy
        assert allocation.target_weight == 0.3
        assert allocation.current_weight == 0.25
        assert allocation.allocated_capital == Decimal("10000")
        assert allocation.max_allocation == 0.4
        assert allocation.min_allocation == 0.05
    
    def test_strategy_allocation_defaults(self):
        """Test StrategyAllocation with default parameters."""
        mock_strategy = Mock()
        mock_strategy.name = "test_strategy"
        
        allocation = StrategyAllocation(
            strategy=mock_strategy,
            target_weight=0.2,
            current_weight=0.15,
            allocated_capital=Decimal("5000")
        )
        
        assert allocation.max_allocation == 0.4  # default
        assert allocation.min_allocation == 0.05  # default


class TestPortfolioAllocator:
    """Test PortfolioAllocator class with comprehensive coverage."""
    
    @pytest.fixture
    def mock_risk_manager(self):
        """Mock risk manager."""
        risk_manager = Mock()
        risk_manager.validate_position_size = Mock(return_value=True)
        risk_manager.get_max_position_size = Mock(return_value=Decimal("1000"))
        return risk_manager
    
    @pytest.fixture
    def mock_strategy(self):
        """Mock strategy."""
        strategy = Mock()
        strategy.name = "test_strategy"
        strategy.strategy_type = StrategyType.TREND_FOLLOWING
        strategy.status = StrategyStatus.ACTIVE
        strategy.get_performance_metrics = AsyncMock(return_value={
            'total_return': 0.15,
            'sharpe_ratio': 1.2,
            'max_drawdown': 0.05,
            'volatility': 0.12,
            'win_rate': 0.65
        })
        strategy.get_historical_returns = AsyncMock(return_value=[0.01, 0.02, -0.005, 0.015])
        return strategy
    
    @pytest.fixture
    def portfolio_allocator(self, mock_risk_manager):
        """Create PortfolioAllocator instance."""
        return PortfolioAllocator(
            total_capital=Decimal("100000"),
            risk_manager=mock_risk_manager,
            max_strategies=5,
            rebalance_frequency_hours=24
        )
    
    def test_portfolio_allocator_initialization(self, mock_risk_manager):
        """Test PortfolioAllocator initialization."""
        allocator = PortfolioAllocator(
            total_capital=Decimal("100000"),
            risk_manager=mock_risk_manager,
            max_strategies=10,
            rebalance_frequency_hours=12,
            min_strategy_allocation=0.1,
            max_strategy_allocation=0.3,
            volatility_lookback_days=30
        )
        
        assert allocator.total_capital == Decimal("100000")
        assert allocator.risk_manager == mock_risk_manager
        assert allocator.max_strategies == 10
        assert allocator.rebalance_frequency == timedelta(hours=12)
        assert allocator.min_strategy_allocation == 0.1
        assert allocator.max_strategy_allocation == 0.3
        assert allocator.volatility_lookback_days == 30
        assert len(allocator.allocations) == 0
    
    def test_portfolio_allocator_defaults(self, mock_risk_manager):
        """Test PortfolioAllocator with default parameters."""
        allocator = PortfolioAllocator(
            total_capital=Decimal("50000"),
            risk_manager=mock_risk_manager
        )
        
        assert allocator.max_strategies == 10  # default
        assert allocator.rebalance_frequency == timedelta(hours=24)  # default
        assert allocator.min_strategy_allocation == 0.05  # default
        assert allocator.max_strategy_allocation == 0.4  # default
        assert allocator.current_regime == MarketRegime.UNKNOWN  # default
    
    @pytest.mark.asyncio
    async def test_add_strategy_success(self, portfolio_allocator, mock_strategy):
        """Test adding a strategy successfully."""
        with patch.object(portfolio_allocator, '_validate_strategy', new_callable=AsyncMock) as mock_validate:
            with patch.object(portfolio_allocator, '_calculate_strategy_correlation', new_callable=AsyncMock) as mock_corr:
                mock_validate.return_value = True
                mock_corr.return_value = 0.3
                
                result = await portfolio_allocator.add_strategy(mock_strategy, target_weight=0.25)
                
                assert result is True
                assert mock_strategy.name in portfolio_allocator.allocations
                allocation = portfolio_allocator.allocations[mock_strategy.name]
                assert allocation.target_weight == 0.25
                assert allocation.strategy == mock_strategy
    
    @pytest.mark.asyncio
    async def test_add_strategy_validation_failure(self, portfolio_allocator, mock_strategy):
        """Test adding strategy with validation failure."""
        with patch.object(portfolio_allocator, '_validate_strategy', new_callable=AsyncMock) as mock_validate:
            mock_validate.return_value = False
            
            with pytest.raises(AllocationError, match="Strategy validation failed"):
                await portfolio_allocator.add_strategy(mock_strategy, target_weight=0.25)
    
    @pytest.mark.asyncio
    async def test_add_strategy_duplicate(self, portfolio_allocator, mock_strategy):
        """Test adding duplicate strategy."""
        with patch.object(portfolio_allocator, '_validate_strategy', new_callable=AsyncMock) as mock_validate:
            with patch.object(portfolio_allocator, '_calculate_strategy_correlation', new_callable=AsyncMock) as mock_corr:
                mock_validate.return_value = True
                mock_corr.return_value = 0.3
                
                # Add strategy first time
                await portfolio_allocator.add_strategy(mock_strategy, target_weight=0.25)
                
                # Try to add same strategy again
                with pytest.raises(AllocationError, match="already exists"):
                    await portfolio_allocator.add_strategy(mock_strategy, target_weight=0.3)
    
    @pytest.mark.asyncio
    async def test_add_strategy_max_strategies_exceeded(self, mock_risk_manager):
        """Test adding strategy when max strategies exceeded."""
        # Create allocator with max 2 strategies
        allocator = PortfolioAllocator(
            total_capital=Decimal("100000"),
            risk_manager=mock_risk_manager,
            max_strategies=2
        )
        
        # Add 2 strategies
        for i in range(2):
            strategy = Mock()
            strategy.name = f"strategy_{i}"
            strategy.strategy_type = StrategyType.TREND_FOLLOWING
            strategy.status = StrategyStatus.ACTIVE
            strategy.get_performance_metrics = AsyncMock(return_value={'sharpe_ratio': 1.0})
            strategy.get_historical_returns = AsyncMock(return_value=[0.01, 0.02])
            
            with patch.object(allocator, '_validate_strategy', new_callable=AsyncMock) as mock_validate:
                with patch.object(allocator, '_calculate_strategy_correlation', new_callable=AsyncMock) as mock_corr:
                    mock_validate.return_value = True
                    mock_corr.return_value = 0.3
                    await allocator.add_strategy(strategy, target_weight=0.3)
        
        # Try to add 3rd strategy
        extra_strategy = Mock()
        extra_strategy.name = "extra_strategy"
        extra_strategy.strategy_type = StrategyType.TREND_FOLLOWING
        extra_strategy.status = StrategyStatus.ACTIVE
        extra_strategy.get_performance_metrics = AsyncMock(return_value={'sharpe_ratio': 1.0})
        extra_strategy.get_historical_returns = AsyncMock(return_value=[0.01, 0.02])
        
        with patch.object(allocator, '_validate_strategy', new_callable=AsyncMock) as mock_validate:
            mock_validate.return_value = True
            
            with pytest.raises(AllocationError, match="Maximum number of strategies"):
                await allocator.add_strategy(extra_strategy, target_weight=0.3)
    
    @pytest.mark.asyncio
    async def test_validate_strategy(self, portfolio_allocator, mock_strategy):
        """Test strategy validation."""
        # Valid strategy
        result = await portfolio_allocator._validate_strategy(mock_strategy)
        assert result is True
        
        # Invalid strategy - no performance metrics
        mock_strategy.get_performance_metrics = AsyncMock(return_value={})
        result = await portfolio_allocator._validate_strategy(mock_strategy)
        assert result is False
        
        # Invalid strategy - inactive status
        mock_strategy.status = StrategyStatus.INACTIVE
        mock_strategy.get_performance_metrics = AsyncMock(return_value={'sharpe_ratio': 1.0})
        result = await portfolio_allocator._validate_strategy(mock_strategy)
        assert result is False
    
    @pytest.mark.asyncio
    async def test_calculate_strategy_correlation(self, portfolio_allocator, mock_strategy):
        """Test strategy correlation calculation."""
        # No existing strategies - should return 0
        correlation = await portfolio_allocator._calculate_strategy_correlation(mock_strategy)
        assert correlation == 0.0
        
        # Add an existing strategy
        existing_strategy = Mock()
        existing_strategy.name = "existing_strategy"
        existing_strategy.get_historical_returns = AsyncMock(return_value=[0.02, -0.01, 0.015, -0.005])
        
        portfolio_allocator.allocations["existing_strategy"] = StrategyAllocation(
            strategy=existing_strategy,
            target_weight=0.3,
            current_weight=0.3,
            allocated_capital=Decimal("30000")
        )
        
        # Calculate correlation with new strategy
        correlation = await portfolio_allocator._calculate_strategy_correlation(mock_strategy)
        assert isinstance(correlation, float)
        assert -1.0 <= correlation <= 1.0
    
    @pytest.mark.asyncio
    async def test_rebalance_portfolio(self, portfolio_allocator, mock_strategy):
        """Test portfolio rebalancing."""
        # Add a strategy
        with patch.object(portfolio_allocator, '_validate_strategy', new_callable=AsyncMock) as mock_validate:
            with patch.object(portfolio_allocator, '_calculate_strategy_correlation', new_callable=AsyncMock) as mock_corr:
                mock_validate.return_value = True
                mock_corr.return_value = 0.3
                await portfolio_allocator.add_strategy(mock_strategy, target_weight=0.5)
        
        # Mock methods called during rebalancing
        with patch.object(portfolio_allocator, '_update_strategy_metrics', new_callable=AsyncMock) as mock_update:
            with patch.object(portfolio_allocator, '_calculate_optimal_weights', new_callable=Mock) as mock_weights:
                with patch.object(portfolio_allocator, '_execute_rebalancing', new_callable=AsyncMock) as mock_execute:
                    with patch.object(portfolio_allocator, '_calculate_portfolio_metrics', new_callable=AsyncMock) as mock_metrics:
                        mock_weights.return_value = {mock_strategy.name: 0.5}
                        mock_execute.return_value = [{"strategy": mock_strategy.name, "action": "rebalanced"}]
                        mock_metrics.return_value = {"total_return": 0.12}
                        
                        result = await portfolio_allocator.rebalance_portfolio()
                        
                        assert isinstance(result, dict)
                        assert "rebalancing_actions" in result
                        assert "portfolio_metrics" in result
                        assert "timestamp" in result
    
    def test_calculate_optimal_weights_empty_portfolio(self, portfolio_allocator):
        """Test calculating optimal weights with empty portfolio."""
        weights = portfolio_allocator._calculate_optimal_weights()
        assert weights == {}
    
    def test_calculate_optimal_weights_single_strategy(self, portfolio_allocator, mock_strategy):
        """Test calculating optimal weights with single strategy."""
        # Add a strategy
        portfolio_allocator.allocations[mock_strategy.name] = StrategyAllocation(
            strategy=mock_strategy,
            target_weight=0.5,
            current_weight=0.4,
            allocated_capital=Decimal("40000")
        )
        
        with patch.object(portfolio_allocator, '_build_returns_matrix') as mock_matrix:
            mock_matrix.return_value = None  # Simulate insufficient data
            
            weights = portfolio_allocator._calculate_optimal_weights()
            assert isinstance(weights, dict)
            assert mock_strategy.name in weights
    
    def test_build_returns_matrix(self, portfolio_allocator, mock_strategy):
        """Test building returns matrix."""
        # Add strategy
        portfolio_allocator.allocations[mock_strategy.name] = StrategyAllocation(
            strategy=mock_strategy,
            target_weight=0.5,
            current_weight=0.4,
            allocated_capital=Decimal("40000")
        )
        
        # Mock historical returns
        mock_strategy.get_historical_returns = Mock(return_value=[0.01, 0.02, -0.005, 0.015])
        
        matrix = portfolio_allocator._build_returns_matrix([mock_strategy.name])
        
        if matrix is not None:
            assert isinstance(matrix, np.ndarray)
            assert matrix.shape[1] == 1  # One strategy
    
    def test_optimize_sharpe_ratio(self, portfolio_allocator):
        """Test Sharpe ratio optimization."""
        # Create mock returns matrix
        returns = np.array([[0.01, 0.02], [0.015, -0.005], [-0.002, 0.018]])
        
        weights = portfolio_allocator._optimize_sharpe_ratio(returns, ["strategy1", "strategy2"])
        
        assert isinstance(weights, dict)
        assert len(weights) == 2
        assert "strategy1" in weights
        assert "strategy2" in weights
        # Weights should sum to 1 (approximately)
        assert abs(sum(weights.values()) - 1.0) < 0.01
    
    def test_apply_weight_constraints(self, portfolio_allocator):
        """Test applying weight constraints."""
        # Test with weights that need constraining
        weights = np.array([0.6, 0.5, -0.1])  # Exceeds max, negative weight
        constrained = portfolio_allocator._apply_weight_constraints(weights)
        
        assert all(w >= portfolio_allocator.min_strategy_allocation for w in constrained)
        assert all(w <= portfolio_allocator.max_strategy_allocation for w in constrained)
        assert abs(sum(constrained) - 1.0) < 0.01  # Should sum to 1
    
    def test_calculate_performance_based_weights(self, portfolio_allocator, mock_strategy):
        """Test performance-based weight calculation."""
        # Add strategy with performance metrics
        portfolio_allocator.allocations[mock_strategy.name] = StrategyAllocation(
            strategy=mock_strategy,
            target_weight=0.5,
            current_weight=0.4,
            allocated_capital=Decimal("40000")
        )
        
        # Mock performance metrics
        portfolio_allocator.strategy_metrics = {
            mock_strategy.name: {
                'sharpe_ratio': 1.5,
                'total_return': 0.2,
                'max_drawdown': 0.08,
                'volatility': 0.15
            }
        }
        
        weights = portfolio_allocator._calculate_performance_based_weights()
        
        assert isinstance(weights, dict)
        assert mock_strategy.name in weights
        assert 0.0 <= weights[mock_strategy.name] <= 1.0
    
    def test_apply_regime_adjustments(self, portfolio_allocator, mock_strategy):
        """Test market regime adjustments."""
        weights = {mock_strategy.name: 0.5}
        
        # Test different regimes
        portfolio_allocator.current_regime = MarketRegime.BULL_MARKET
        adjusted_bull = portfolio_allocator._apply_regime_adjustments(weights.copy())
        
        portfolio_allocator.current_regime = MarketRegime.BEAR_MARKET
        adjusted_bear = portfolio_allocator._apply_regime_adjustments(weights.copy())
        
        assert isinstance(adjusted_bull, dict)
        assert isinstance(adjusted_bear, dict)
        assert mock_strategy.name in adjusted_bull
        assert mock_strategy.name in adjusted_bear
    
    @pytest.mark.asyncio
    async def test_execute_rebalancing(self, portfolio_allocator, mock_strategy):
        """Test rebalancing execution."""
        # Add strategy
        portfolio_allocator.allocations[mock_strategy.name] = StrategyAllocation(
            strategy=mock_strategy,
            target_weight=0.4,
            current_weight=0.5,
            allocated_capital=Decimal("50000")
        )
        
        target_weights = {mock_strategy.name: 0.4}
        
        actions = await portfolio_allocator._execute_rebalancing(target_weights)
        
        assert isinstance(actions, list)
        if actions:  # Only if rebalancing actually occurred
            assert all("strategy" in action for action in actions)
            assert all("action" in action for action in actions)
    
    @pytest.mark.asyncio
    async def test_calculate_portfolio_metrics(self, portfolio_allocator, mock_strategy):
        """Test portfolio metrics calculation."""
        # Add strategy
        portfolio_allocator.allocations[mock_strategy.name] = StrategyAllocation(
            strategy=mock_strategy,
            target_weight=0.5,
            current_weight=0.5,
            allocated_capital=Decimal("50000")
        )
        
        # Set up strategy metrics
        portfolio_allocator.strategy_metrics = {
            mock_strategy.name: {
                'total_return': 0.15,
                'volatility': 0.12,
                'sharpe_ratio': 1.25,
                'max_drawdown': 0.06
            }
        }
        
        metrics = await portfolio_allocator._calculate_portfolio_metrics()
        
        assert isinstance(metrics, dict)
        assert "total_return" in metrics
        assert "volatility" in metrics
        assert "sharpe_ratio" in metrics
        assert "max_drawdown" in metrics
        assert "diversification_ratio" in metrics
    
    @pytest.mark.asyncio
    async def test_update_market_regime(self, portfolio_allocator):
        """Test market regime update."""
        await portfolio_allocator.update_market_regime(MarketRegime.BULL_MARKET)
        assert portfolio_allocator.current_regime == MarketRegime.BULL_MARKET
        
        await portfolio_allocator.update_market_regime(MarketRegime.BEAR_MARKET)
        assert portfolio_allocator.current_regime == MarketRegime.BEAR_MARKET
    
    @pytest.mark.asyncio
    async def test_remove_strategy(self, portfolio_allocator, mock_strategy):
        """Test removing a strategy."""
        # Add strategy first
        with patch.object(portfolio_allocator, '_validate_strategy', new_callable=AsyncMock) as mock_validate:
            with patch.object(portfolio_allocator, '_calculate_strategy_correlation', new_callable=AsyncMock) as mock_corr:
                mock_validate.return_value = True
                mock_corr.return_value = 0.3
                await portfolio_allocator.add_strategy(mock_strategy, target_weight=0.5)
        
        # Remove strategy
        result = await portfolio_allocator.remove_strategy(mock_strategy.name, reason="underperforming")
        
        assert result is True
        assert mock_strategy.name not in portfolio_allocator.allocations
    
    @pytest.mark.asyncio
    async def test_remove_strategy_not_found(self, portfolio_allocator):
        """Test removing non-existent strategy."""
        result = await portfolio_allocator.remove_strategy("non_existent", reason="test")
        assert result is False
    
    def test_get_allocation_status(self, portfolio_allocator, mock_strategy):
        """Test getting allocation status."""
        # Add strategy
        portfolio_allocator.allocations[mock_strategy.name] = StrategyAllocation(
            strategy=mock_strategy,
            target_weight=0.5,
            current_weight=0.4,
            allocated_capital=Decimal("40000")
        )
        
        status = portfolio_allocator.get_allocation_status()
        
        assert isinstance(status, dict)
        assert "total_capital" in status
        assert "allocated_capital" in status
        assert "available_capital" in status
        assert "strategies" in status
        assert "market_regime" in status
        
        # Check strategy details
        strategies = status["strategies"]
        assert mock_strategy.name in strategies
        strategy_info = strategies[mock_strategy.name]
        assert "target_weight" in strategy_info
        assert "current_weight" in strategy_info
        assert "allocated_capital" in strategy_info
    
    @pytest.mark.asyncio
    async def test_should_rebalance(self, portfolio_allocator):
        """Test rebalancing decision logic."""
        # Initially should not rebalance (no strategies)
        should_rebalance = await portfolio_allocator.should_rebalance()
        assert should_rebalance is False
        
        # Set last rebalance to long ago
        portfolio_allocator.last_rebalance = datetime.now(timezone.utc) - timedelta(hours=25)
        should_rebalance = await portfolio_allocator.should_rebalance()
        assert should_rebalance is True  # Time-based rebalancing
        
        # Set recent rebalance
        portfolio_allocator.last_rebalance = datetime.now(timezone.utc) - timedelta(minutes=30)
        should_rebalance = await portfolio_allocator.should_rebalance()
        assert should_rebalance is False  # Too recent
    
    @pytest.mark.asyncio
    async def test_update_strategy_metrics(self, portfolio_allocator, mock_strategy):
        """Test updating strategy metrics."""
        # Add strategy
        portfolio_allocator.allocations[mock_strategy.name] = StrategyAllocation(
            strategy=mock_strategy,
            target_weight=0.5,
            current_weight=0.5,
            allocated_capital=Decimal("50000")
        )
        
        await portfolio_allocator._update_strategy_metrics()
        
        # Check that strategy metrics were updated
        assert mock_strategy.name in portfolio_allocator.strategy_metrics
        metrics = portfolio_allocator.strategy_metrics[mock_strategy.name]
        assert isinstance(metrics, dict)
        # Should contain the metrics returned by the mock
        assert "total_return" in metrics
        assert "sharpe_ratio" in metrics