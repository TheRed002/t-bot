"""
Unit tests for P-013E Hybrid Strategies - Rule-Based AI Strategy.

Tests cover:
- TechnicalRuleEngine functionality (RSI, MA, volume analysis)
- AIPredictor machine learning components
- RuleBasedAIStrategy hybrid signal generation
- Conflict resolution mechanisms
- Performance attribution and weight adjustment
- Signal validation and position sizing
- Integration with regime detection
- Error handling and edge cases
"""

from datetime import datetime, timezone
from decimal import Decimal
from unittest.mock import patch

import numpy as np
import pytest

from src.core.types import (
    MarketData,
    Position,
    PositionSide,
    PositionStatus,
    Signal,
    SignalDirection,
    StrategyType,
)
from src.risk_management.regime_detection import MarketRegime
from src.strategies.hybrid.rule_based_ai import (
    AIPredictor,
    RuleBasedAIStrategy,
    TechnicalRuleEngine,
)


class TestTechnicalRuleEngine:
    """Test TechnicalRuleEngine functionality."""

    @pytest.fixture
    def config(self):
        """Create test configuration for rule engine."""
        return {
            "rsi_period": 14,
            "ma_short_period": 10,
            "ma_long_period": 20,
            "volume_threshold": 1.5,
        }

    @pytest.fixture
    def rule_engine(self, config):
        """Create rule engine instance."""
        return TechnicalRuleEngine(config)

    def test_rule_engine_initialization(self, config):
        """Test rule engine initialization."""
        engine = TechnicalRuleEngine(config)

        assert engine.rsi_period == 14
        assert engine.ma_short_period == 10
        assert engine.ma_long_period == 20
        assert engine.volume_threshold == 1.5

        # Check default rule weights
        assert "rsi_oversold" in engine.rule_weights
        assert "rsi_overbought" in engine.rule_weights
        assert "ma_crossover" in engine.rule_weights

        # Check performance tracking initialization
        assert "rsi_oversold" in engine.rule_performance
        assert engine.rule_performance["rsi_oversold"]["wins"] == 0

    def test_rsi_calculation(self, rule_engine):
        """Test RSI calculation accuracy."""
        # Create price series with known RSI
        prices = [100, 101, 102, 101, 100, 99, 98, 99, 100, 101, 102, 103, 102, 101, 100]

        rsi = rule_engine.calculate_rsi(prices)

        # RSI should be between 0 and 100
        assert 0 <= rsi <= 100

        # Test with insufficient data
        short_prices = [100, 101, 102]
        rsi_short = rule_engine.calculate_rsi(short_prices)
        assert rsi_short == 50.0  # Neutral RSI

        # Test with all increasing prices (should approach 100)
        increasing_prices = [100 + i for i in range(20)]
        rsi_high = rule_engine.calculate_rsi(increasing_prices)
        assert rsi_high > 70  # Should be overbought

        # Test with all decreasing prices (should approach 0)
        decreasing_prices = [100 - i for i in range(20)]
        rsi_low = rule_engine.calculate_rsi(decreasing_prices)
        assert rsi_low < 30  # Should be oversold

    def test_moving_averages_calculation(self, rule_engine):
        """Test moving averages calculation."""
        prices = [
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115,
            116,
            117,
            118,
            119,
        ]

        ma_short, ma_long = rule_engine.calculate_moving_averages(prices)

        # Short MA should be higher than long MA in uptrend
        assert ma_short > ma_long

        # Test with insufficient data
        short_prices = [100, 101, 102]
        ma_short_insufficient, ma_long_insufficient = rule_engine.calculate_moving_averages(
            short_prices
        )
        assert ma_short_insufficient == 102
        assert ma_long_insufficient == 102

        # Verify calculation accuracy
        expected_short = np.mean(prices[-10:])  # Last 10 prices
        expected_long = np.mean(prices[-20:])  # Last 20 prices
        assert abs(ma_short - expected_short) < 0.001
        assert abs(ma_long - expected_long) < 0.001

    def test_rule_evaluation_rsi_signals(self, rule_engine):
        """Test RSI-based signal generation."""
        # Create market data
        market_data = MarketData(
            symbol="BTC/USD",
            timestamp=datetime.now(timezone.utc),
            open=Decimal("99"),
            high=Decimal("101"),
            low=Decimal("98"),
            close=Decimal("100"),
            volume=Decimal("1000"),
            bid_price=Decimal("99.5"),
            ask_price=Decimal("100.5"),
            exchange="test"
        )

        # Test oversold condition (RSI < 30)
        oversold_prices = [100 - i * 2 for i in range(20)]  # Decreasing prices
        volume_history = [1000] * 20

        result = rule_engine.evaluate_rules(market_data, oversold_prices, volume_history)

        assert "signals" in result
        assert "rsi" in result
        assert result["rsi"] < 30

        # Should generate buy signal
        buy_signals = [s for s in result["signals"] if s["direction"] == SignalDirection.BUY]
        assert len(buy_signals) > 0
        assert "rsi_oversold" in result["rules_triggered"]

        # Test overbought condition (RSI > 70)
        overbought_prices = [100 + i * 2 for i in range(20)]  # Increasing prices

        result_overbought = rule_engine.evaluate_rules(
            market_data, overbought_prices, volume_history
        )

        assert result_overbought["rsi"] > 70

        # Should generate sell signal
        sell_signals = [
            s for s in result_overbought["signals"] if s["direction"] == SignalDirection.SELL
        ]
        assert len(sell_signals) > 0
        assert "rsi_overbought" in result_overbought["rules_triggered"]

    def test_rule_evaluation_ma_crossover(self, rule_engine):
        """Test moving average crossover signals."""
        market_data = MarketData(
            symbol="BTC/USD",
            timestamp=datetime.now(timezone.utc),
            open=Decimal("109"),
            high=Decimal("111"),
            low=Decimal("108"),
            close=Decimal("110"),
            volume=Decimal("1000"),
            bid_price=Decimal("109.5"),
            ask_price=Decimal("110.5"),
            exchange="test"
        )

        # Create bullish crossover (short MA > long MA)
        bullish_prices = [
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115,
            116,
            117,
            118,
            119,
        ]
        volume_history = [1000] * 20

        result = rule_engine.evaluate_rules(market_data, bullish_prices, volume_history)

        assert result["ma_short"] > result["ma_long"]

        # Should generate buy signal for bullish crossover
        ma_signals = [s for s in result["signals"] if s["rule"] == "ma_crossover"]
        if ma_signals:  # Might not trigger if threshold not met
            assert ma_signals[0]["direction"] == SignalDirection.BUY
            assert "ma_crossover_bullish" in result["rules_triggered"]

    def test_rule_evaluation_volume_confirmation(self, rule_engine):
        """Test volume confirmation signals."""
        market_data = MarketData(
            symbol="BTC/USD",
            timestamp=datetime.now(timezone.utc),
            open=Decimal("104"),
            high=Decimal("106"),
            low=Decimal("103"),
            close=Decimal("105"),
            volume=Decimal("2000"),  # High volume
            bid_price=Decimal("104.5"),
            ask_price=Decimal("105.5"),
            exchange="test"
        )

        price_history = [100, 101, 102, 103, 104, 105]
        volume_history = [1000, 1000, 1000, 1000, 1000]  # Low average volume

        result = rule_engine.evaluate_rules(market_data, price_history, volume_history)

        # Should detect high volume
        volume_signals = [s for s in result["signals"] if s["rule"] == "volume_confirmation"]
        if volume_signals:
            assert "high_volume" in result["rules_triggered"]

    def test_rule_evaluation_insufficient_data(self, rule_engine):
        """Test rule evaluation with insufficient data."""
        market_data = MarketData(
            symbol="BTC/USD",
            timestamp=datetime.now(timezone.utc),
            open=Decimal("99"),
            high=Decimal("101"),
            low=Decimal("98"),
            close=Decimal("100"),
            volume=Decimal("1000"),
            bid_price=Decimal("99.5"),
            ask_price=Decimal("100.5"),
            exchange="test"
        )

        # Insufficient price history
        short_prices = [100, 101, 102]
        short_volume = [1000, 1000, 1000]

        result = rule_engine.evaluate_rules(market_data, short_prices, short_volume)

        assert result["signals"] == []
        assert result["confidence"] == 0.0
        assert result["rules_triggered"] == []

    def test_rule_performance_tracking(self, rule_engine):
        """Test rule performance tracking and updates."""
        initial_performance = rule_engine.rule_performance["rsi_oversold"].copy()

        # Update performance with win
        rule_engine.update_rule_performance("rsi_oversold", 150.0)  # Positive performance

        assert (
            rule_engine.rule_performance["rsi_oversold"]["total"]
            == initial_performance["total"] + 1
        )
        assert (
            rule_engine.rule_performance["rsi_oversold"]["wins"] == initial_performance["wins"] + 1
        )
        assert (
            rule_engine.rule_performance["rsi_oversold"]["losses"] == initial_performance["losses"]
        )

        # Update performance with loss
        rule_engine.update_rule_performance("rsi_oversold", -75.0)  # Negative performance

        assert (
            rule_engine.rule_performance["rsi_oversold"]["total"]
            == initial_performance["total"] + 2
        )
        assert (
            rule_engine.rule_performance["rsi_oversold"]["losses"]
            == initial_performance["losses"] + 1
        )

    def test_rule_weight_adjustment(self, rule_engine):
        """Test dynamic rule weight adjustment."""
        # Simulate performance history
        for _ in range(15):  # More than minimum 10 trades
            rule_engine.update_rule_performance("rsi_oversold", 100.0)  # All wins

        original_weight = rule_engine.rule_weights["rsi_oversold"]

        rule_engine.adjust_rule_weights()

        # Weight should increase for good performance
        assert rule_engine.rule_weights["rsi_oversold"] > original_weight

        # Test poor performance
        for _ in range(15):
            rule_engine.update_rule_performance("rsi_overbought", -50.0)  # All losses

        original_weight_bad = rule_engine.rule_weights["rsi_overbought"]
        rule_engine.adjust_rule_weights()

        # Weight should decrease for poor performance
        assert rule_engine.rule_weights["rsi_overbought"] < original_weight_bad


class TestAIPredictor:
    """Test AIPredictor functionality."""

    @pytest.fixture
    def config(self):
        """Create test configuration for AI predictor."""
        return {"n_estimators": 50, "max_depth": 5, "feature_window": 20, "retrain_frequency": 50}

    @pytest.fixture
    def ai_predictor(self, config):
        """Create AI predictor instance."""
        return AIPredictor(config)

    def test_ai_predictor_initialization(self, config):
        """Test AI predictor initialization."""
        predictor = AIPredictor(config)

        assert predictor.model.n_estimators == 50
        assert predictor.model.max_depth == 5
        assert predictor.feature_window == 20
        assert predictor.retrain_frequency == 50
        assert not predictor.is_trained
        assert predictor.prediction_count == 0

    def test_feature_preparation(self, ai_predictor):
        """Test feature preparation for ML model."""
        # Create sample price and volume history
        np.random.seed(42)
        price_history = (100 * np.exp(np.cumsum(np.random.normal(0, 0.01, 50)))).tolist()
        volume_history = np.random.uniform(1000, 5000, 50).tolist()

        features = ai_predictor.prepare_features(price_history, volume_history)

        assert features.size > 0
        assert features.shape[0] == 1  # Single sample
        assert features.shape[1] > 5  # Multiple features

        # Test with insufficient data
        short_prices = [100, 101, 102]
        short_volumes = [1000, 1000, 1000]

        features_short = ai_predictor.prepare_features(short_prices, short_volumes)
        assert features_short.size == 0

    def test_feature_content_validation(self, ai_predictor):
        """Test that features contain expected components."""
        # Create controlled data
        price_history = [100 + i * 0.1 for i in range(50)]  # Steadily increasing
        volume_history = [1000 + i * 10 for i in range(50)]  # Steadily increasing

        features = ai_predictor.prepare_features(price_history, volume_history)

        # Should have returns, technical indicators, volume features
        assert features.shape[1] >= 10  # At least 10 features

        # Features should be finite
        assert np.all(np.isfinite(features))

    @pytest.mark.asyncio
    async def test_model_training(self, ai_predictor):
        """Test AI model training process."""
        # Create training data
        training_data = []
        np.random.seed(42)

        for i in range(100):
            price_history = (100 * np.exp(np.cumsum(np.random.normal(0, 0.01, 50)))).tolist()
            volume_history = np.random.uniform(1000, 5000, 50).tolist()
            future_return = np.random.normal(0, 0.02)

            training_data.append(
                {
                    "price_history": price_history,
                    "volume_history": volume_history,
                    "future_return": future_return,
                }
            )

        await ai_predictor.train_model(training_data)

        assert ai_predictor.is_trained

        # Test prediction after training
        prediction = await ai_predictor.predict(
            training_data[0]["price_history"], training_data[0]["volume_history"]
        )

        assert "direction" in prediction
        assert "confidence" in prediction
        assert "probabilities" in prediction
        assert prediction["direction"] in [
            SignalDirection.BUY,
            SignalDirection.SELL,
            SignalDirection.HOLD,
        ]
        assert 0 <= prediction["confidence"] <= 1
        assert len(prediction["probabilities"]) == 2

    @pytest.mark.asyncio
    async def test_model_training_insufficient_data(self, ai_predictor):
        """Test model training with insufficient data."""
        # Create insufficient training data
        training_data = [
            {
                "price_history": [100, 101, 102],
                "volume_history": [1000, 1000, 1000],
                "future_return": 0.01,
            }
        ] * 5  # Only 5 samples

        await ai_predictor.train_model(training_data)

        # Should handle gracefully but not train
        assert not ai_predictor.is_trained

    @pytest.mark.asyncio
    async def test_model_training_error_handling(self, ai_predictor):
        """Test error handling during model training."""
        # Create invalid training data
        invalid_data = [
            {
                "price_history": [],  # Empty history
                "volume_history": [],
                "future_return": 0.01,
            }
        ] * 100

        await ai_predictor.train_model(invalid_data)

        # Should handle gracefully
        assert not ai_predictor.is_trained

    @pytest.mark.asyncio
    async def test_prediction_without_training(self, ai_predictor):
        """Test prediction when model is not trained."""
        price_history = [100, 101, 102, 103, 104]
        volume_history = [1000, 1000, 1000, 1000, 1000]

        prediction = await ai_predictor.predict(price_history, volume_history)

        assert prediction["direction"] == SignalDirection.HOLD
        assert prediction["confidence"] == 0.0
        assert prediction["probabilities"] == [0.5, 0.5]

    @pytest.mark.asyncio
    async def test_prediction_error_handling(self, ai_predictor):
        """Test prediction error handling."""
        # Force training to create model
        ai_predictor.is_trained = True

        # Try prediction with invalid data
        prediction = await ai_predictor.predict([], [])  # Empty data

        assert prediction["direction"] == SignalDirection.HOLD
        assert prediction["confidence"] == 0.0

    def test_performance_tracking(self, ai_predictor):
        """Test AI performance tracking."""
        # Add some predictions
        predictions = [
            {"direction": SignalDirection.BUY, "confidence": 0.8},
            {"direction": SignalDirection.SELL, "confidence": 0.7},
            {"direction": SignalDirection.HOLD, "confidence": 0.6},
        ]

        outcomes = [0.05, -0.03, 0.01]  # Corresponding actual outcomes

        for pred, outcome in zip(predictions, outcomes, strict=False):
            ai_predictor.update_performance(pred, outcome)

        assert len(ai_predictor.predictions_made) == 3
        assert len(ai_predictor.actual_outcomes) == 3

        # Test performance metrics
        metrics = ai_predictor.get_performance_metrics()
        assert "accuracy" in metrics
        assert "precision" in metrics
        assert "recall" in metrics
        assert 0 <= metrics["accuracy"] <= 1


class TestRuleBasedAIStrategy:
    """Test RuleBasedAIStrategy functionality."""

    @pytest.fixture
    def config(self):
        """Create test configuration for hybrid strategy."""
        return {
            "strategy_id": "test_hybrid_001",
            "name": "TestHybridStrategy",
            "symbol": "BTC/USD",
            "timeframe": "1h",
            "symbols": ["BTC/USD"],
            "position_size_pct": 0.02,
            "stop_loss_pct": 0.05,
            "take_profit_pct": 0.10,
            "rule_weight": 0.6,
            "ai_weight": 0.4,
            "min_confidence_threshold": 0.65,
            "conflict_resolution": "weighted_average",
            "rules": {"rsi_period": 14, "ma_short_period": 10, "ma_long_period": 20},
            "ai": {"n_estimators": 50, "feature_window": 20},
            "regime_detection": {},
        }

    @pytest.fixture
    def strategy(self, config):
        """Create hybrid strategy instance."""
        return RuleBasedAIStrategy(config)

    @pytest.fixture
    def market_data(self):
        """Create sample market data."""
        return MarketData(
            symbol="BTC/USD",
            timestamp=datetime.now(timezone.utc),
            price=Decimal("50000"),
            volume=Decimal("1000"),
            bid=Decimal("49950"),
            ask=Decimal("50050"),
            open=Decimal("49800"),
            high=Decimal("50200"),
            low=Decimal("49700"),
            close=Decimal("50000"),
            exchange="test_exchange",
        )

    def test_strategy_initialization(self, config):
        """Test hybrid strategy initialization."""
        strategy = RuleBasedAIStrategy(config)

        assert strategy.name == "TestHybridStrategy"
        assert strategy.config.strategy_type == StrategyType.CUSTOM
        assert strategy.rule_weight == 0.6
        assert strategy.ai_weight == 0.4
        assert strategy.min_confidence_threshold == 0.65
        assert strategy.conflict_resolution_method == "weighted_average"

        assert isinstance(strategy.rule_engine, TechnicalRuleEngine)
        assert isinstance(strategy.ai_predictor, AIPredictor)

        assert len(strategy.price_history) == 0
        assert len(strategy.volume_history) == 0
        assert len(strategy.signal_history) == 0

    @pytest.mark.asyncio
    async def test_signal_generation_insufficient_data(self, strategy, market_data):
        """Test signal generation with insufficient historical data."""
        signals = await strategy._generate_signals_impl(market_data)

        # Should return empty list due to insufficient data
        assert signals == []

    @pytest.mark.asyncio
    async def test_signal_generation_with_data(self, strategy, market_data):
        """Test signal generation with sufficient historical data."""
        # Populate price and volume history
        symbol = market_data.symbol
        strategy.price_history[symbol] = [50000 + i * 10 for i in range(100)]
        strategy.volume_history[symbol] = [1000 + i * 5 for i in range(100)]

        with patch.object(strategy.regime_detector, "detect_comprehensive_regime") as mock_regime:
            mock_regime.return_value = MarketRegime.TRENDING_UP

            with patch.object(strategy.rule_engine, "evaluate_rules") as mock_rules:
                mock_rules.return_value = {
                    "signals": [
                        {
                            "rule": "rsi_oversold",
                            "direction": SignalDirection.BUY,
                            "confidence": 0.8,
                            "weight": 0.3,
                        }
                    ],
                    "rules_triggered": ["rsi_oversold"],
                    "rsi": 25.0,
                    "ma_short": 50010,
                    "ma_long": 50000,
                }

            with patch.object(strategy.ai_predictor, "predict") as mock_ai:
                mock_ai.return_value = {
                    "direction": SignalDirection.BUY,
                    "confidence": 0.7,
                    "probabilities": [0.3, 0.7],
                }

                signals = await strategy._generate_signals_impl(market_data)

                if signals:  # Might be empty if confidence too low
                    assert len(signals) == 1
                    signal = signals[0]
                    assert isinstance(signal, Signal)
                    assert signal.symbol == market_data.symbol
                    assert signal.direction in [
                        SignalDirection.BUY,
                        SignalDirection.SELL,
                        SignalDirection.HOLD,
                    ]

    def test_weighted_average_conflict_resolution(self, strategy):
        """Test weighted average conflict resolution."""
        result = strategy._weighted_average_resolution(
            SignalDirection.BUY, 0.8, SignalDirection.BUY, 0.6
        )

        assert result["direction"] == SignalDirection.BUY
        assert result["confidence"] > 0

        # Test conflicting signals
        result_conflict = strategy._weighted_average_resolution(
            SignalDirection.BUY, 0.7, SignalDirection.SELL, 0.8
        )

        # Should have some direction based on weights
        assert result_conflict["direction"] in [
            SignalDirection.BUY,
            SignalDirection.SELL,
            SignalDirection.HOLD,
        ]

    def test_highest_confidence_resolution(self, strategy):
        """Test highest confidence conflict resolution."""
        result = strategy._highest_confidence_resolution(
            SignalDirection.BUY, 0.6, SignalDirection.SELL, 0.8
        )

        assert result["direction"] == SignalDirection.SELL  # Higher confidence
        assert result["confidence"] == 0.8

    def test_consensus_resolution(self, strategy):
        """Test consensus conflict resolution."""
        # Test agreement
        result_agree = strategy._consensus_resolution(
            SignalDirection.BUY, 0.7, SignalDirection.BUY, 0.8
        )

        assert result_agree["direction"] == SignalDirection.BUY
        assert result_agree["confidence"] == 0.75  # Average

        # Test disagreement
        result_disagree = strategy._consensus_resolution(
            SignalDirection.BUY, 0.7, SignalDirection.SELL, 0.8
        )

        assert result_disagree["direction"] == SignalDirection.HOLD
        assert result_disagree["confidence"] == 0.0

    @pytest.mark.asyncio
    async def test_signal_validation(self, strategy):
        """Test signal validation."""
        # Valid signal
        valid_signal = Signal(
            direction=SignalDirection.BUY,
            strength=Decimal("0.75"),
            timestamp=datetime.now(timezone.utc),
            symbol="BTC/USD",
            source="TestStrategy",
            metadata={
                "rule_direction": "buy",
                "ai_direction": "buy",
                "resolution_method": "weighted_average",
            },
        )

        is_valid = await strategy.validate_signal(valid_signal)
        assert is_valid

        # Invalid signal - low confidence
        invalid_signal = Signal(
            direction=SignalDirection.BUY,
            strength=Decimal("0.3"),  # Below threshold
            timestamp=datetime.now(timezone.utc),
            symbol="BTC/USD",
            source="TestStrategy",
            metadata={},
        )

        is_invalid = await strategy.validate_signal(invalid_signal)
        assert not is_invalid

        # Invalid signal - HOLD direction
        hold_signal = Signal(
            direction=SignalDirection.HOLD,
            strength=Decimal("0.8"),
            timestamp=datetime.now(timezone.utc),
            symbol="BTC/USD",
            source="TestStrategy",
            metadata={},
        )

        is_hold_invalid = await strategy.validate_signal(hold_signal)
        assert not is_hold_invalid

    def test_position_sizing(self, strategy):
        """Test position size calculation based on signal confidence."""
        signal = Signal(
            direction=SignalDirection.BUY,
            strength=Decimal("0.8"),
            timestamp=datetime.now(timezone.utc),
            symbol="BTC/USD",
            source="TestStrategy",
            metadata={"rule_direction": "buy", "ai_direction": "buy"},
        )

        position_size = strategy.get_position_size(signal)

        assert isinstance(position_size, Decimal)
        assert position_size > 0
        assert position_size <= Decimal("0.05")  # Max 5%

        # Test with disagreement (should reduce size)
        signal_disagree = Signal(
            direction=SignalDirection.BUY,
            strength=Decimal("0.8"),
            timestamp=datetime.now(timezone.utc),
            symbol="BTC/USD",
            source="TestStrategy",
            metadata={
                "rule_direction": "buy",
                "ai_direction": "sell",  # Disagreement
            },
        )

        position_size_disagree = strategy.get_position_size(signal_disagree)
        assert position_size_disagree < position_size

    def test_exit_decision_stop_loss(self, strategy):
        """Test exit decision based on stop loss."""
        position = Position(
            symbol="BTC/USD",
            side=PositionSide.LONG,
            status=PositionStatus.OPEN,
            quantity=Decimal("0.1"),
            entry_price=Decimal("50000"),
            current_price=Decimal("47500"),
            unrealized_pnl=Decimal("-250"),
            opened_at=datetime.now(timezone.utc),
            exchange="binance",
        )

        # Market data with loss exceeding stop loss
        market_data = MarketData(
            symbol="BTC/USD",
            timestamp=datetime.now(timezone.utc),
            open=Decimal("47400"),
            high=Decimal("47600"),
            low=Decimal("47300"),
            close=Decimal("47500"),  # 5% loss
            volume=Decimal("1000"),
            bid_price=Decimal("47450"),
            ask_price=Decimal("47550"),
            exchange="test"
        )

        should_exit = strategy.should_exit(position, market_data)
        assert should_exit  # Should trigger stop loss

    def test_exit_decision_take_profit(self, strategy):
        """Test exit decision based on take profit."""
        position = Position(
            symbol="BTC/USD",
            side=PositionSide.LONG,
            status=PositionStatus.OPEN,
            quantity=Decimal("0.1"),
            entry_price=Decimal("50000"),
            current_price=Decimal("55500"),
            unrealized_pnl=Decimal("550"),
            opened_at=datetime.now(timezone.utc),
            exchange="binance",
        )

        # Market data with profit exceeding take profit
        market_data = MarketData(
            symbol="BTC/USD",
            timestamp=datetime.now(timezone.utc),
            open=Decimal("55400"),
            high=Decimal("55600"),
            low=Decimal("55300"),
            close=Decimal("55500"),  # 11% profit
            volume=Decimal("1000"),
            bid_price=Decimal("55450"),
            ask_price=Decimal("55550"),
            exchange="test"
        )

        should_exit = strategy.should_exit(position, market_data)
        assert should_exit  # Should trigger take profit

    def test_exit_decision_hybrid_signals(self, strategy):
        """Test exit decision based on opposing hybrid signals."""
        position = Position(
            symbol="BTC/USD",
            side=PositionSide.LONG,
            status=PositionStatus.OPEN,
            quantity=Decimal("0.1"),
            entry_price=Decimal("50000"),
            current_price=Decimal("50100"),
            unrealized_pnl=Decimal("10"),
            opened_at=datetime.now(timezone.utc),
            exchange="binance",
        )

        # Set up price history for rule evaluation
        strategy.price_history["BTC/USD"] = [50000 + i * 10 for i in range(30)]
        strategy.volume_history["BTC/USD"] = [1000] * 30

        market_data = MarketData(
            symbol="BTC/USD",
            timestamp=datetime.now(timezone.utc),
            open=Decimal("50000"),
            high=Decimal("50200"),
            low=Decimal("49900"),
            close=Decimal("50100"),  # Small profit
            volume=Decimal("1000"),
            bid_price=Decimal("50050"),
            ask_price=Decimal("50150"),
            exchange="test"
        )

        with patch.object(strategy.rule_engine, "evaluate_rules") as mock_rules:
            # Strong opposing signals
            mock_rules.return_value = {
                "signals": [
                    {
                        "rule": "rsi_overbought",
                        "direction": SignalDirection.SELL,
                        "confidence": 0.9,
                        "weight": 0.3,
                    },
                    {
                        "rule": "ma_crossover",
                        "direction": SignalDirection.SELL,
                        "confidence": 0.8,
                        "weight": 0.4,
                    },
                ],
                "rules_triggered": ["rsi_overbought", "ma_crossover_bearish"],
            }

            should_exit = strategy.should_exit(position, market_data)
            # Might exit based on opposing signals strength

    @pytest.mark.asyncio
    async def test_strategy_start(self, strategy):
        """Test strategy start process."""
        await strategy._on_start()

        # Should complete without error
        # If signal history exists, should attempt to retrain

    def test_component_weight_adjustment(self, strategy):
        """Test dynamic component weight adjustment."""
        # Simulate performance data
        strategy.component_performance["rules"]["total"] = 25
        strategy.component_performance["rules"]["wins"] = 20  # 80% win rate
        strategy.component_performance["ai"]["total"] = 25
        strategy.component_performance["ai"]["wins"] = 10  # 40% win rate

        original_rule_weight = strategy.rule_weight
        original_ai_weight = strategy.ai_weight

        strategy.adjust_component_weights()

        # Rule component performed better, should get higher weight
        assert strategy.rule_weight > original_rule_weight
        assert strategy.ai_weight < original_ai_weight

        # Weights should still sum to approximately 1
        assert abs((strategy.rule_weight + strategy.ai_weight) - 1.0) < 0.01

    def test_strategy_statistics(self, strategy):
        """Test strategy statistics generation."""
        stats = strategy.get_strategy_statistics()

        assert "component_weights" in stats
        assert "component_performance" in stats
        assert "rule_performance" in stats
        assert "ai_performance" in stats
        assert "signal_history_length" in stats
        assert "ai_model_trained" in stats
        assert "conflict_resolution_method" in stats

        assert stats["component_weights"]["rule_weight"] == strategy.rule_weight
        assert stats["component_weights"]["ai_weight"] == strategy.ai_weight
        assert stats["conflict_resolution_method"] == strategy.conflict_resolution_method


# Integration tests
@pytest.mark.asyncio
async def test_hybrid_strategy_integration():
    """Integration test of complete hybrid strategy."""
    config = {
        "strategy_id": "integration_test_001",
        "name": "IntegrationTestStrategy",
        "symbol": "BTC/USD",
        "timeframe": "1h",
        "symbols": ["BTC/USD"],
        "position_size_pct": 0.02,
        "stop_loss_pct": 0.05,
        "take_profit_pct": 0.10,
        "rule_weight": 0.6,
        "ai_weight": 0.4,
        "min_confidence_threshold": 0.6,
        "conflict_resolution": "weighted_average",
        "rules": {"rsi_period": 14, "ma_short_period": 10, "ma_long_period": 20},
        "ai": {"n_estimators": 10, "feature_window": 20},
        "regime_detection": {},
    }

    strategy = RuleBasedAIStrategy(config)

    # Populate with historical data
    symbol = "BTC/USD"
    np.random.seed(42)

    # Generate realistic price series
    base_price = 50000
    price_changes = np.random.normal(0, 0.02, 100)
    prices = [base_price]
    for change in price_changes:
        prices.append(prices[-1] * (1 + change))

    strategy.price_history[symbol] = prices
    strategy.volume_history[symbol] = np.random.uniform(1000, 5000, 101).tolist()

    # Create market data
    current_price = Decimal(str(prices[-1]))
    market_data = MarketData(
        symbol=symbol,
        timestamp=datetime.now(timezone.utc),
        open=current_price * Decimal("0.995"),
        high=current_price * Decimal("1.005"),
        low=current_price * Decimal("0.990"),
        close=current_price,
        volume=Decimal("2000"),
        exchange="test_exchange",
        bid_price=current_price * Decimal("0.999"),
        ask_price=current_price * Decimal("1.001"),
    )

    with patch.object(strategy.regime_detector, "detect_comprehensive_regime") as mock_regime:
        mock_regime.return_value = MarketRegime.TRENDING_UP

        # Generate signals
        signals = await strategy._generate_signals_impl(market_data)

        # Should handle the process without errors
        assert isinstance(signals, list)

        # If signal generated, validate it
        for signal in signals:
            assert isinstance(signal, Signal)
            assert signal.symbol == symbol

            # Test validation
            is_valid = await strategy.validate_signal(signal)
            if is_valid:
                # Test position sizing
                position_size = strategy.get_position_size(signal)
                assert position_size > 0


@pytest.mark.performance
@pytest.mark.asyncio
async def test_hybrid_strategy_performance():
    """Test hybrid strategy performance with large dataset."""
    from src.core.types import StrategyType
    
    config = {
        "strategy_id": "perf_test_001",
        "strategy_type": StrategyType.CUSTOM,
        "name": "PerformanceTestStrategy",
        "symbol": "BTC/USD",
        "timeframe": "1h",
        "symbols": ["BTC/USD"],
        "position_size_pct": 0.02,
        "rule_weight": 0.5,
        "ai_weight": 0.5,
        "min_confidence_threshold": 0.5,
        "rules": {"rsi_period": 14},
        "ai": {"n_estimators": 10, "feature_window": 20},
        "regime_detection": {},
    }

    strategy = RuleBasedAIStrategy(config)

    # Generate large dataset
    symbol = "BTC/USD"
    np.random.seed(42)

    # 1000 data points
    large_prices = [50000]
    for _ in range(1000):
        change = np.random.normal(0, 0.01)
        large_prices.append(large_prices[-1] * (1 + change))

    strategy.price_history[symbol] = large_prices
    strategy.volume_history[symbol] = np.random.uniform(1000, 5000, 1001).tolist()

    market_data = MarketData(
        symbol=symbol,
        timestamp=datetime.now(timezone.utc),
        open=Decimal(str(large_prices[-2] if len(large_prices) > 1 else large_prices[-1])),
        high=Decimal(str(large_prices[-1] * 1.002)),
        low=Decimal(str(large_prices[-1] * 0.998)),
        close=Decimal(str(large_prices[-1])),
        volume=Decimal("2000"),
        exchange="test_exchange",
        bid_price=Decimal(str(large_prices[-1] * 0.999)),
        ask_price=Decimal(str(large_prices[-1] * 1.001)),
    )

    with patch.object(strategy.regime_detector, "detect_comprehensive_regime") as mock_regime:
        mock_regime.return_value = MarketRegime.TRENDING_UP

        import time

        start_time = time.time()

        # Generate signals multiple times
        for _ in range(10):
            signals = await strategy._generate_signals_impl(market_data)

        execution_time = time.time() - start_time

        # Should complete within reasonable time
        assert execution_time < 5.0  # 5 seconds for 10 signal generations with 1000 data points
