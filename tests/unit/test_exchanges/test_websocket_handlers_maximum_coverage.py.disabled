"""
Comprehensive tests for WebSocket handlers to achieve maximum coverage.

This test file covers:
- BinanceWebSocketHandler
- CoinbaseWebSocketHandler 
- OKXWebSocketHandler

Aims to cover every method, property, and code path in the WebSocket handlers
to maximize line coverage towards the 70% target.
"""

import asyncio
import pytest
from datetime import datetime, timezone
from decimal import Decimal
from unittest.mock import AsyncMock, MagicMock, Mock, patch, call
from typing import Dict, Any, List

from src.exchanges.binance_websocket import BinanceWebSocketHandler
from src.exchanges.coinbase_websocket import CoinbaseWebSocketHandler
from src.exchanges.okx_websocket import OKXWebSocketManager as OKXWebSocketHandler
from src.core.config import Config
from src.core.exceptions import ExchangeError
from src.core.types import OrderBook, Ticker, Trade, OrderSide


@pytest.fixture
def mock_config():
    """Create mock config for WebSocket testing."""
    config = Mock(spec=Config)
    config.exchange = Mock()
    config.exchange.get_websocket_config = Mock(return_value={
        "reconnect_attempts": 10,
        "reconnect_delay": 1.0,
        "max_reconnect_delay": 60.0,
        "message_timeout": 60,
        "ping_interval": 30,
        "pong_timeout": 10
    })
    config.exchange.binance_api_key = "test_api_key"
    config.exchange.coinbase_api_key = "test_api_key"
    config.exchange.okx_api_key = "test_api_key"
    return config


class TestBinanceWebSocketHandler:
    """Test Binance WebSocket handler functionality."""
    
    @pytest.fixture
    def mock_client(self):
        """Create mock Binance client."""
        client = Mock()
        client.get_listen_key = AsyncMock(return_value={"listenKey": "test_listen_key"})
        client.ping_listen_key = AsyncMock(return_value={"msg": "pong"})
        return client
    
    @pytest.fixture
    def binance_ws_handler(self, mock_config, mock_client):
        """Create Binance WebSocket handler instance."""
        with patch('src.exchanges.binance_websocket.BinanceSocketManager') as mock_ws_manager:
            mock_ws_manager.return_value = Mock()
            handler = BinanceWebSocketHandler(mock_config, mock_client, "binance")
            return handler
    
    def test_initialization(self, mock_config, mock_client):
        """Test Binance WebSocket handler initialization."""
        with patch('src.exchanges.binance_websocket.BinanceSocketManager') as mock_ws_manager:
            mock_manager = Mock()
            mock_ws_manager.return_value = mock_manager
            
            handler = BinanceWebSocketHandler(mock_config, mock_client, "binance")
            
            assert handler.config == mock_config
            assert handler.client == mock_client
            assert handler.exchange_name == "binance"
            assert handler.ws_manager == mock_manager
            assert handler.connected is False
            assert handler.active_streams == {}
            assert handler.callbacks == {}
            assert handler.stream_handlers == {}
            assert handler.reconnect_attempts == 0
            assert handler.max_reconnect_attempts == 10
            assert handler._shutdown is False
            assert handler.last_message_time is None
    
    @pytest.mark.asyncio
    async def test_connect_success(self, binance_ws_handler):
        """Test successful connection."""
        binance_ws_handler.connected = False
        
        with patch.object(binance_ws_handler, '_health_monitor', new_callable=AsyncMock):
            result = await binance_ws_handler.connect()
            
            assert result is True
            assert binance_ws_handler.connected is True
            assert binance_ws_handler._connection_start_time is not None
    
    @pytest.mark.asyncio
    async def test_connect_already_connected(self, binance_ws_handler):
        """Test connection when already connected."""
        binance_ws_handler.connected = True
        
        result = await binance_ws_handler.connect()
        assert result is True
    
    @pytest.mark.asyncio
    async def test_disconnect_success(self, binance_ws_handler):
        """Test successful disconnection."""
        # Set up connected state
        binance_ws_handler.connected = True
        
        # Create proper mock tasks - use regular Mock, not AsyncMock for asyncio.Task-like behavior
        mock_health_task = Mock()
        mock_health_task.done.return_value = False  # done() should return a boolean, not a coroutine
        mock_health_task.cancel = Mock()
        binance_ws_handler._health_check_task = mock_health_task
        
        # Mock stream tasks - use regular Mock, not AsyncMock for asyncio.Task-like behavior
        mock_stream1 = Mock()
        mock_stream1.done.return_value = False  # done() should return a boolean
        mock_stream1.cancel = Mock()
        mock_stream2 = Mock()
        mock_stream2.done.return_value = False  # done() should return a boolean
        mock_stream2.cancel = Mock()
        
        binance_ws_handler.stream_handlers = {
            "btcusdt@ticker": mock_stream1,
            "ethusdt@depth20@100ms": mock_stream2
        }
        
        binance_ws_handler.active_streams = {
            "btcusdt@ticker": "mock_stream_obj1",
            "ethusdt@depth20@100ms": "mock_stream_obj2"
        }
        
        # Mock the _close_stream method
        with patch.object(binance_ws_handler, '_close_stream', new_callable=AsyncMock) as mock_close:
            await binance_ws_handler.disconnect()
            
            assert binance_ws_handler.connected is False
            assert binance_ws_handler._shutdown is True
            
            # Verify tasks were cancelled
            mock_health_task.cancel.assert_called_once()
            mock_stream1.cancel.assert_called_once()
            mock_stream2.cancel.assert_called_once()
            
            # Verify streams were closed
            assert mock_close.call_count >= 2  # Should close active streams
    
    @pytest.mark.asyncio
    async def test_subscribe_to_ticker(self, binance_ws_handler):
        """Test subscribing to ticker stream."""
        callback = AsyncMock()
        symbol = "BTCUSDT"
        
        # Mock WebSocket manager
        mock_ws_stream = Mock()
        binance_ws_handler.ws_manager.symbol_ticker_socket = Mock(return_value=mock_ws_stream)
        
        with patch.object(binance_ws_handler, '_handle_ticker_stream', new_callable=AsyncMock) as mock_handler:
            with patch('asyncio.create_task') as mock_create_task:
                mock_task = Mock()
                mock_create_task.return_value = mock_task
                
                await binance_ws_handler.subscribe_to_ticker_stream(symbol, callback)
                
                stream_key = f"{symbol.lower()}@ticker"  # Actual stream name format
                assert stream_key in binance_ws_handler.callbacks
                assert callback in binance_ws_handler.callbacks[stream_key]
                assert stream_key in binance_ws_handler.stream_handlers
                assert binance_ws_handler.stream_handlers[stream_key] == mock_task
    
    @pytest.mark.asyncio
    async def test_subscribe_to_order_book(self, binance_ws_handler):
        """Test subscribing to order book stream."""
        callback = AsyncMock()
        symbol = "BTCUSDT"
        depth = 10
        
        # Mock WebSocket manager
        mock_ws_stream = Mock()
        binance_ws_handler.ws_manager.depth_socket = Mock(return_value=mock_ws_stream)
        
        with patch.object(binance_ws_handler, '_handle_orderbook_stream', new_callable=AsyncMock) as mock_handler:
            with patch('asyncio.create_task') as mock_create_task:
                mock_task = Mock()
                mock_create_task.return_value = mock_task
                
                await binance_ws_handler.subscribe_to_orderbook_stream(symbol, str(depth), callback)
                
                stream_key = f"{symbol.lower()}@depth{depth}@100ms"  # Actual stream name format
                assert stream_key in binance_ws_handler.callbacks
                assert callback in binance_ws_handler.callbacks[stream_key]
    
    @pytest.mark.asyncio
    async def test_subscribe_to_trades(self, binance_ws_handler):
        """Test subscribing to trades stream."""
        callback = AsyncMock()
        symbol = "BTCUSDT"
        
        # Mock WebSocket manager
        mock_ws_stream = Mock()
        binance_ws_handler.ws_manager.trade_socket = Mock(return_value=mock_ws_stream)
        
        with patch.object(binance_ws_handler, '_handle_trade_stream', new_callable=AsyncMock):
            with patch('asyncio.create_task') as mock_create_task:
                mock_task = Mock()
                mock_create_task.return_value = mock_task
                
                await binance_ws_handler.subscribe_to_trade_stream(symbol, callback)
                
                stream_key = f"{symbol.lower()}@trade"  # Actual stream name format
                assert stream_key in binance_ws_handler.callbacks
                assert callback in binance_ws_handler.callbacks[stream_key]
    
    @pytest.mark.asyncio
    async def test_subscribe_to_user_data(self, binance_ws_handler):
        """Test subscribing to user data stream."""
        callback = AsyncMock()
        
        # Mock WebSocket manager
        mock_ws_stream = Mock()
        binance_ws_handler.ws_manager.user_socket = Mock(return_value=mock_ws_stream)
        
        with patch.object(binance_ws_handler, '_handle_user_data_stream', new_callable=AsyncMock):
            with patch('asyncio.create_task') as mock_create_task:
                mock_task = Mock()
                mock_create_task.return_value = mock_task
                
                await binance_ws_handler.subscribe_to_user_data_stream(callback)
                
                stream_key = "user_data"
                assert stream_key in binance_ws_handler.callbacks
                assert callback in binance_ws_handler.callbacks[stream_key]
    
    @pytest.mark.asyncio
    async def test_unsubscribe_from_stream(self, binance_ws_handler):
        """Test unsubscribing from stream."""
        # Set up active stream with correct format
        stream_key = "btcusdt@ticker"  # Actual stream name format
        mock_task = Mock()
        mock_task.cancel = Mock()
        binance_ws_handler.stream_handlers[stream_key] = mock_task
        binance_ws_handler.callbacks[stream_key] = [AsyncMock()]
        
        await binance_ws_handler.unsubscribe_from_stream(stream_key)
        
        assert stream_key not in binance_ws_handler.stream_handlers
        assert stream_key not in binance_ws_handler.callbacks
        mock_task.cancel.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_handle_ticker_stream(self, binance_ws_handler):
        """Test ticker stream handling."""
        # Set up stream and callback
        stream_key = "btcusdt@ticker"  # Correct stream key format
        callback = AsyncMock()
        binance_ws_handler.callbacks[stream_key] = [callback]
        
        # Mock WebSocket stream
        mock_stream = AsyncMock()
        mock_stream.__aiter__ = AsyncMock(return_value=iter([
            {
                "s": "BTCUSDT",
                "c": "50000.0",
                "b": "49999.9",
                "a": "50000.1",
                "v": "1000.5",
                "P": "2.5",
                "E": 1634567890000
            }
        ]))
        mock_stream.__anext__ = AsyncMock(side_effect=StopAsyncIteration)
        
        with patch.object(binance_ws_handler, '_notify_callbacks', new_callable=AsyncMock) as mock_notify:
            await binance_ws_handler._handle_ticker_stream(stream_key, mock_stream)  # Correct parameter order
            mock_notify.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_handle_order_book_stream(self, binance_ws_handler):
        """Test order book stream handling."""
        # Set up stream and callback
        stream_key = "btcusdt@depth10@100ms"  # Correct stream key format
        callback = AsyncMock()
        binance_ws_handler.callbacks[stream_key] = [callback]
        
        # Mock WebSocket stream
        mock_stream = AsyncMock()
        mock_stream.__aiter__ = AsyncMock(return_value=iter([
            {
                "s": "BTCUSDT",
                "b": [["49999.9", "1.5"], ["49999.8", "2.0"]],
                "a": [["50000.1", "1.2"], ["50000.2", "1.8"]],
                "E": 1634567890000
            }
        ]))
        mock_stream.__anext__ = AsyncMock(side_effect=StopAsyncIteration)
        
        with patch.object(binance_ws_handler, '_notify_callbacks', new_callable=AsyncMock) as mock_notify:
            await binance_ws_handler._handle_order_book_stream(mock_stream, stream_key)
            mock_notify.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_handle_trades_stream(self, binance_ws_handler):
        """Test trades stream handling."""
        # Set up stream and callback
        stream_key = "btcusdt@trade"  # Correct stream key format
        callback = AsyncMock()
        binance_ws_handler.callbacks[stream_key] = [callback]
        
        # Mock WebSocket stream
        mock_stream = AsyncMock()
        mock_stream.__aiter__ = AsyncMock(return_value=iter([
            {
                "s": "BTCUSDT",
                "t": 123456,
                "p": "50000.0",
                "q": "0.5",
                "m": False,  # taker is buyer (sell trade)
                "T": 1634567890000
            }
        ]))
        mock_stream.__anext__ = AsyncMock(side_effect=StopAsyncIteration)
        
        with patch.object(binance_ws_handler, '_notify_callbacks', new_callable=AsyncMock) as mock_notify:
            await binance_ws_handler._handle_trade_stream(stream_key, mock_stream)  # Correct method name and parameter order
            mock_notify.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_handle_user_data_stream(self, binance_ws_handler):
        """Test user data stream handling."""
        # Set up stream and callback
        stream_key = "user_data"
        callback = AsyncMock()
        binance_ws_handler.callbacks[stream_key] = [callback]
        
        # Mock WebSocket stream
        mock_stream = AsyncMock()
        mock_stream.__aiter__ = AsyncMock(return_value=iter([
            {
                "e": "outboundAccountPosition",
                "E": 1634567890000,
                "u": 1634567890000,
                "B": [
                    {"a": "BTC", "f": "0.5", "l": "0.0"},
                    {"a": "USDT", "f": "10000.0", "l": "500.0"}
                ]
            }
        ]))
        mock_stream.__anext__ = AsyncMock(side_effect=StopAsyncIteration)
        
        with patch.object(binance_ws_handler, '_notify_callbacks', new_callable=AsyncMock) as mock_notify:
            await binance_ws_handler._handle_user_data_stream(mock_stream, stream_key)
            mock_notify.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_notify_callbacks(self, binance_ws_handler):
        """Test callback notification."""
        stream_key = "test_stream"
        callback1 = AsyncMock()
        callback2 = AsyncMock()
        binance_ws_handler.callbacks[stream_key] = [callback1, callback2]
        
        test_data = {"test": "data"}
        
        await binance_ws_handler._notify_callbacks(stream_key, test_data)
        
        callback1.assert_called_once_with(test_data)
        callback2.assert_called_once_with(test_data)
    
    @pytest.mark.asyncio
    async def test_notify_callbacks_with_exception(self, binance_ws_handler):
        """Test callback notification with callback exception."""
        stream_key = "test_stream"
        callback = AsyncMock(side_effect=Exception("Callback error"))
        binance_ws_handler.callbacks[stream_key] = [callback]
        
        test_data = {"test": "data"}
        
        # Should not raise exception, only log error
        await binance_ws_handler._notify_callbacks(stream_key, test_data)
        callback.assert_called_once_with(test_data)
    
    
    @pytest.mark.asyncio
    async def test_health_monitor(self, binance_ws_handler):
        """Test health monitor."""
        binance_ws_handler.connected = True
        binance_ws_handler.last_message_time = datetime.now(timezone.utc)
        call_count = 0
        
        def side_effect():
            nonlocal call_count
            call_count += 1
            if call_count >= 2:  # Stop after 2 iterations
                binance_ws_handler.connected = False
        
        with patch('asyncio.sleep', new_callable=AsyncMock, side_effect=side_effect):
            await binance_ws_handler._health_monitor()
            
            assert call_count >= 1
    
    def test_parse_ticker_data(self, binance_ws_handler):
        """Test ticker data parsing."""
        raw_data = {
            "s": "BTCUSDT",
            "c": "50000.0",
            "b": "49999.9",
            "a": "50000.1",
            "v": "1000.5",
            "P": "2.5",
            "E": 1634567890000
        }
        
        ticker = binance_ws_handler._convert_ticker_message(raw_data)
        
        assert isinstance(ticker, Ticker)
        assert ticker.symbol == "BTCUSDT"
        assert ticker.price == Decimal("50000.0")
        assert ticker.bid == Decimal("49999.9")
        assert ticker.ask == Decimal("50000.1")
        assert ticker.volume == Decimal("1000.5")
        assert ticker.change_24h == Decimal("2.5")
    
    def test_parse_order_book_data(self, binance_ws_handler):
        """Test order book data parsing."""
        raw_data = {
            "s": "BTCUSDT",
            "b": [["49999.9", "1.5"], ["49999.8", "2.0"]],
            "a": [["50000.1", "1.2"], ["50000.2", "1.8"]],
            "E": 1634567890000
        }
        
        order_book = binance_ws_handler._convert_orderbook_message(raw_data)
        
        assert isinstance(order_book, OrderBook)
        assert order_book.symbol == "BTCUSDT"
        assert len(order_book.bids) == 2
        assert len(order_book.asks) == 2
        assert order_book.bids[0] == (Decimal("49999.9"), Decimal("1.5"))
        assert order_book.asks[0] == (Decimal("50000.1"), Decimal("1.2"))
    
    def test_parse_trade_data(self, binance_ws_handler):
        """Test trade data parsing."""
        raw_data = {
            "s": "BTCUSDT",
            "t": 123456,
            "p": "50000.0",
            "q": "0.5",
            "m": False,  # taker is buyer (sell trade)
            "T": 1634567890000
        }
        
        trade = binance_ws_handler._convert_trade_message(raw_data)
        
        assert isinstance(trade, Trade)
        assert trade.symbol == "BTCUSDT"
        assert trade.trade_id == "123456"
        assert trade.price == Decimal("50000.0")
        assert trade.quantity == Decimal("0.5")
        assert trade.side == OrderSide.SELL
    
    @pytest.mark.asyncio
    async def test_handle_stream_exception(self, binance_ws_handler):
        """Test stream exception handling."""
        stream_key = "test_stream"
        
        # Mock stream that raises exception
        mock_stream = AsyncMock()
        mock_stream.__aiter__ = AsyncMock(side_effect=Exception("Stream error"))
        
        with patch.object(binance_ws_handler, '_handle_stream_error', new_callable=AsyncMock) as mock_error:
            await binance_ws_handler._handle_ticker_stream(stream_key, mock_stream)  # Correct parameter order
            mock_error.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_schedule_reconnect(self, binance_ws_handler):
        """Test reconnection scheduling."""
        binance_ws_handler.connected = False
        binance_ws_handler.reconnect_attempts = 0
        
        with patch.object(binance_ws_handler, '_reconnect_after_delay', new_callable=AsyncMock):
            with patch('asyncio.create_task') as mock_create_task:
                mock_task = Mock()
                mock_create_task.return_value = mock_task
                
                await binance_ws_handler._schedule_reconnect()
                
                assert binance_ws_handler.reconnect_attempts == 1
    
    @pytest.mark.asyncio
    async def test_health_check(self, binance_ws_handler):
        """Test health check."""
        binance_ws_handler.connected = True
        binance_ws_handler.last_message_time = datetime.now(timezone.utc)
        
        result = await binance_ws_handler.health_check()
        assert result is True
    
    def test_get_connection_metrics(self, binance_ws_handler):
        """Test getting connection metrics."""
        binance_ws_handler._total_messages_received = 100
        binance_ws_handler._total_reconnections = 5
        binance_ws_handler._connection_start_time = datetime.now(timezone.utc)
        
        metrics = binance_ws_handler.get_connection_metrics()
        
        assert isinstance(metrics, dict)
        assert metrics["total_messages_received"] == 100
        assert metrics["total_reconnections"] == 5
        assert "uptime_seconds" in metrics
        assert "active_streams" in metrics


class TestCoinbaseWebSocketHandler:
    """Test Coinbase WebSocket handler functionality."""
    
    @pytest.fixture
    def coinbase_ws_handler(self, mock_config):
        """Create Coinbase WebSocket handler instance."""
        with patch('src.exchanges.coinbase_websocket.websockets') as mock_websockets:
            handler = CoinbaseWebSocketHandler(mock_config, "coinbase")
            return handler
    
    def test_initialization(self, mock_config):
        """Test Coinbase WebSocket handler initialization."""
        with patch('src.exchanges.coinbase_websocket.websockets'):
            handler = CoinbaseWebSocketHandler(mock_config, "coinbase")
            
            assert handler.config == mock_config
            assert handler.exchange_name == "coinbase"
            assert handler.connected is False
            assert handler.subscriptions == {}
            assert handler.message_handlers == {}
            assert handler._websocket is None
    
    @pytest.mark.asyncio
    async def test_connect_success(self, coinbase_ws_handler):
        """Test successful connection to Coinbase WebSocket."""
        mock_websocket = AsyncMock()
        
        with patch('src.exchanges.coinbase_websocket.websockets.connect', new_callable=AsyncMock, return_value=mock_websocket):
            with patch.object(coinbase_ws_handler, '_start_message_handler', new_callable=AsyncMock):
                result = await coinbase_ws_handler.connect()
                
                assert result is True
                assert coinbase_ws_handler.connected is True
                assert coinbase_ws_handler._websocket == mock_websocket
    
    @pytest.mark.asyncio
    async def test_subscribe_to_ticker(self, coinbase_ws_handler):
        """Test subscribing to Coinbase ticker stream."""
        callback = AsyncMock()
        symbol = "BTC-USD"
        
        coinbase_ws_handler._websocket = AsyncMock()
        coinbase_ws_handler.connected = True
        
        await coinbase_ws_handler.subscribe_to_ticker(symbol, callback)
        
        # Should send subscription message
        coinbase_ws_handler._websocket.send.assert_called_once()
        
        # Should register callback
        channel_key = f"ticker_{symbol}"
        assert channel_key in coinbase_ws_handler.subscriptions
        assert callback in coinbase_ws_handler.subscriptions[channel_key]
    
    @pytest.mark.asyncio
    async def test_handle_message(self, coinbase_ws_handler):
        """Test message handling."""
        # Test ticker message
        ticker_message = {
            "type": "ticker",
            "product_id": "BTC-USD",
            "price": "50000.0",
            "best_bid": "49999.9",
            "best_ask": "50000.1",
            "volume_24h": "1000.5",
            "time": "2023-10-18T10:00:00.000000Z"
        }
        
        callback = AsyncMock()
        coinbase_ws_handler.subscriptions["ticker_BTC-USD"] = [callback]
        
        with patch.object(coinbase_ws_handler, '_notify_callbacks', new_callable=AsyncMock) as mock_notify:
            await coinbase_ws_handler._handle_message(ticker_message)
            mock_notify.assert_called_once()


class TestOKXWebSocketHandler:
    """Test OKX WebSocket handler functionality."""
    
    @pytest.fixture
    def okx_ws_handler(self, mock_config):
        """Create OKX WebSocket handler instance."""
        with patch('src.exchanges.okx_websocket.websockets') as mock_websockets:
            handler = OKXWebSocketHandler(mock_config, "okx")
            return handler
    
    def test_initialization(self, mock_config):
        """Test OKX WebSocket handler initialization."""
        with patch('src.exchanges.okx_websocket.websockets'):
            handler = OKXWebSocketHandler(mock_config, "okx")
            
            assert handler.config == mock_config
            assert handler.exchange_name == "okx"
            assert handler.connected is False
            assert handler.subscriptions == {}
            assert handler.message_handlers == {}
            assert handler._websocket is None
    
    @pytest.mark.asyncio
    async def test_connect_success(self, okx_ws_handler):
        """Test successful connection to OKX WebSocket."""
        mock_websocket = AsyncMock()
        
        with patch('src.exchanges.okx_websocket.websockets.connect', new_callable=AsyncMock, return_value=mock_websocket):
            with patch.object(okx_ws_handler, '_start_message_handler', new_callable=AsyncMock):
                with patch.object(okx_ws_handler, '_start_ping_handler', new_callable=AsyncMock):
                    result = await okx_ws_handler.connect()
                    
                    assert result is True
                    assert okx_ws_handler.connected is True
                    assert okx_ws_handler._websocket == mock_websocket
    
    @pytest.mark.asyncio
    async def test_subscribe_to_ticker(self, okx_ws_handler):
        """Test subscribing to OKX ticker stream."""
        callback = AsyncMock()
        symbol = "BTC-USDT"
        
        okx_ws_handler._websocket = AsyncMock()
        okx_ws_handler.connected = True
        
        await okx_ws_handler.subscribe_to_ticker(symbol, callback)
        
        # Should send subscription message
        okx_ws_handler._websocket.send.assert_called_once()
        
        # Should register callback
        channel_key = f"tickers_{symbol}"
        assert channel_key in okx_ws_handler.subscriptions
        assert callback in okx_ws_handler.subscriptions[channel_key]
    
    @pytest.mark.asyncio
    async def test_handle_message(self, okx_ws_handler):
        """Test OKX message handling."""
        # Test ticker message
        ticker_message = {
            "arg": {"channel": "tickers", "instId": "BTC-USDT"},
            "data": [
                {
                    "instId": "BTC-USDT",
                    "last": "50000.0",
                    "bidPx": "49999.9",
                    "askPx": "50000.1",
                    "vol24h": "1000.5",
                    "chg24h": "0.025",
                    "ts": "1634567890000"
                }
            ]
        }
        
        callback = AsyncMock()
        okx_ws_handler.subscriptions["tickers_BTC-USDT"] = [callback]
        
        with patch.object(okx_ws_handler, '_notify_callbacks', new_callable=AsyncMock) as mock_notify:
            await okx_ws_handler._handle_message(ticker_message)
            mock_notify.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_ping_handler(self, okx_ws_handler):
        """Test ping handler."""
        okx_ws_handler.connected = True
        okx_ws_handler._websocket = AsyncMock()
        call_count = 0
        
        def side_effect():
            nonlocal call_count
            call_count += 1
            if call_count >= 2:  # Stop after 2 iterations
                okx_ws_handler.connected = False
        
        with patch('asyncio.sleep', new_callable=AsyncMock, side_effect=side_effect):
            await okx_ws_handler._ping_handler()
            
            # Should have sent ping
            assert okx_ws_handler._websocket.send.call_count >= 1
    
    def test_parse_ticker_data(self, okx_ws_handler):
        """Test OKX ticker data parsing."""
        raw_data = {
            "instId": "BTC-USDT",
            "last": "50000.0",
            "bidPx": "49999.9",
            "askPx": "50000.1",
            "vol24h": "1000.5",
            "chg24h": "0.025",
            "ts": "1634567890000"
        }
        
        ticker = okx_ws_handler._parse_ticker_data(raw_data)
        
        assert isinstance(ticker, Ticker)
        assert ticker.symbol == "BTC-USDT"
        assert ticker.price == Decimal("50000.0")
        assert ticker.bid == Decimal("49999.9")
        assert ticker.ask == Decimal("50000.1")
        assert ticker.volume == Decimal("1000.5")
        assert ticker.change_24h == Decimal("2.5")  # Percentage converted
    
    def test_parse_order_book_data(self, okx_ws_handler):
        """Test OKX order book data parsing."""
        raw_data = {
            "instId": "BTC-USDT",
            "bids": [["49999.9", "1.5", "0", "2"], ["49999.8", "2.0", "0", "1"]],
            "asks": [["50000.1", "1.2", "0", "1"], ["50000.2", "1.8", "0", "2"]],
            "ts": "1634567890000"
        }
        
        order_book = okx_ws_handler._parse_order_book_data(raw_data)
        
        assert isinstance(order_book, OrderBook)
        assert order_book.symbol == "BTC-USDT"
        assert len(order_book.bids) == 2
        assert len(order_book.asks) == 2
        assert order_book.bids[0] == (Decimal("49999.9"), Decimal("1.5"))
        assert order_book.asks[0] == (Decimal("50000.1"), Decimal("1.2"))


class TestWebSocketErrorHandling:
    """Test WebSocket error handling across all handlers."""
    
    @pytest.mark.asyncio
    async def test_connection_error_handling(self, mock_config):
        """Test WebSocket connection error handling."""
        with patch('src.exchanges.binance_websocket.BinanceSocketManager'):
            handler = BinanceWebSocketHandler(mock_config, Mock(), "binance")
            
            # Mock connection failure
            with patch.object(handler.ws_manager, 'start', side_effect=Exception("Connection failed")):
                result = await handler.connect()
                assert result is False
    
    @pytest.mark.asyncio
    async def test_message_processing_error(self, mock_config):
        """Test message processing error handling."""
        with patch('src.exchanges.coinbase_websocket.websockets'):
            handler = CoinbaseWebSocketHandler(mock_config, "coinbase")
            
            # Test invalid message format
            invalid_message = {"invalid": "format"}
            
            # Should not raise exception, only log error
            await handler._handle_message(invalid_message)
    
    @pytest.mark.asyncio
    async def test_network_disconnection_recovery(self, mock_config):
        """Test network disconnection and recovery."""
        with patch('src.exchanges.okx_websocket.websockets'):
            handler = OKXWebSocketHandler(mock_config, "okx")
            handler.connected = True
            
            # Simulate network disconnection
            with patch.object(handler, '_handle_reconnection', new_callable=AsyncMock) as mock_reconnect:
                # Mock WebSocket exception
                handler._websocket = AsyncMock()
                handler._websocket.recv = AsyncMock(side_effect=Exception("Connection lost"))
                
                await handler._message_handler()
                mock_reconnect.assert_called_once()


class TestWebSocketIntegrationScenarios:
    """Test WebSocket integration scenarios."""
    
    @pytest.mark.asyncio
    async def test_multiple_stream_management(self, mock_config, mock_client):
        """Test managing multiple WebSocket streams."""
        with patch('src.exchanges.binance_websocket.BinanceSocketManager'):
            handler = BinanceWebSocketHandler(mock_config, mock_client, "binance")
            
            # Subscribe to multiple streams
            callback1 = AsyncMock()
            callback2 = AsyncMock()
            callback3 = AsyncMock()
            
            with patch.object(handler, '_handle_ticker_stream', new_callable=AsyncMock):
                with patch.object(handler, '_handle_order_book_stream', new_callable=AsyncMock):
                    with patch.object(handler, '_handle_trades_stream', new_callable=AsyncMock):
                        await handler.subscribe_to_ticker("BTCUSDT", callback1)
                        await handler.subscribe_to_order_book("ETHUSDT", callback2)
                        await handler.subscribe_to_trades("ADAUSDT", callback3)
                        
                        assert len(handler.stream_handlers) == 3
                        assert len(handler.callbacks) == 3
                        
                        # Test cleanup
                        await handler.disconnect()
                        assert len(handler.stream_handlers) == 0
    
    @pytest.mark.asyncio
    async def test_callback_exception_isolation(self, mock_config):
        """Test that callback exceptions don't affect other callbacks."""
        with patch('src.exchanges.coinbase_websocket.websockets'):
            handler = CoinbaseWebSocketHandler(mock_config, "coinbase")
            
            # Set up callbacks - one that throws exception, one that works
            failing_callback = AsyncMock(side_effect=Exception("Callback error"))
            working_callback = AsyncMock()
            
            stream_key = "ticker_BTC-USD"
            handler.subscriptions[stream_key] = [failing_callback, working_callback]
            
            test_data = {"test": "data"}
            
            await handler._notify_callbacks(stream_key, test_data)
            
            # Both callbacks should have been called
            failing_callback.assert_called_once_with(test_data)
            working_callback.assert_called_once_with(test_data)
    
    @pytest.mark.asyncio
    async def test_concurrent_subscription_management(self, mock_config):
        """Test concurrent subscription and unsubscription operations."""
        with patch('src.exchanges.okx_websocket.websockets'):
            handler = OKXWebSocketHandler(mock_config, "okx")
            handler.connected = True
            handler._websocket = AsyncMock()
            
            # Perform concurrent operations
            tasks = []
            for i in range(5):
                callback = AsyncMock()
                symbol = f"BTC-USDT-{i}"
                task = asyncio.create_task(handler.subscribe_to_ticker(symbol, callback))
                tasks.append(task)
            
            # Wait for all subscriptions
            await asyncio.gather(*tasks)
            
            assert len(handler.subscriptions) == 5
            
            # Test concurrent unsubscriptions
            unsubscribe_tasks = []
            for i in range(5):
                channel_key = f"tickers_BTC-USDT-{i}"
                task = asyncio.create_task(handler.unsubscribe_from_stream(channel_key))
                unsubscribe_tasks.append(task)
            
            await asyncio.gather(*unsubscribe_tasks)
            
            # All subscriptions should be removed
            assert len(handler.subscriptions) == 0


if __name__ == "__main__":
    pytest.main([__file__, "-v"])